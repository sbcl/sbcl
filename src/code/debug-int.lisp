;;;; the implementation of the programmer's interface to writing
;;;; debugging tools

;;;; This software is part of the SBCL system. See the README file for
;;;; more information.
;;;;
;;;; This software is derived from the CMU CL system, which was
;;;; written at Carnegie Mellon University and released into the
;;;; public domain. The software is in the public domain and is
;;;; provided with absolutely no warranty. See the COPYING and CREDITS
;;;; files for more information.

(in-package "SB!DI")

;;; FIXME: There are an awful lot of package prefixes in this code.
;;; Couldn't we have SB-DI use the SB-C and SB-VM packages?

;;;; conditions

;;;; The interface to building debugging tools signals conditions that
;;;; prevent it from adhering to its contract. These are
;;;; serious-conditions because the program using the interface must
;;;; handle them before it can correctly continue execution. These
;;;; debugging conditions are not errors since it is no fault of the
;;;; programmers that the conditions occur. The interface does not
;;;; provide for programs to detect these situations other than
;;;; calling a routine that detects them and signals a condition. For
;;;; example, programmers call A which may fail to return successfully
;;;; due to a lack of debug information, and there is no B the they
;;;; could have called to realize A would fail. It is not an error to
;;;; have called A, but it is an error for the program to then ignore
;;;; the signal generated by A since it cannot continue without A's
;;;; correctly returning a value or performing some operation.
;;;;
;;;; Use DEBUG-SIGNAL to signal these conditions.

(define-condition debug-condition (serious-condition)
  ()
  #!+sb-doc
  (:documentation
   "All DEBUG-CONDITIONs inherit from this type. These are serious conditions
    that must be handled, but they are not programmer errors."))

(define-condition no-debug-info (debug-condition)
  ((code-component :reader no-debug-info-code-component
		   :initarg :code-component))
  #!+sb-doc
  (:documentation "There is no usable debugging information available.")
  (:report (lambda (condition stream)
	     (declare (ignore condition))
	     (fresh-line stream)
	     (format stream
		     "no debug information available for ~S~%"
		     (no-debug-info-code-component condition)))))

(define-condition no-debug-function-returns (debug-condition)
  ((debug-function :reader no-debug-function-returns-debug-function
		   :initarg :debug-function))
  #!+sb-doc
  (:documentation
   "The system could not return values from a frame with DEBUG-FUNCTION since
    it lacked information about returning values.")
  (:report (lambda (condition stream)
	     (let ((fun (debug-function-function
			 (no-debug-function-returns-debug-function condition))))
	       (format stream
		       "~&Cannot return values from ~:[frame~;~:*~S~] since ~
			the debug information lacks details about returning ~
			values here."
		       fun)))))

(define-condition no-debug-blocks (debug-condition)
  ((debug-function :reader no-debug-blocks-debug-function
		   :initarg :debug-function))
  #!+sb-doc
  (:documentation "The debug-function has no debug-block information.")
  (:report (lambda (condition stream)
	     (format stream "~&~S has no debug-block information."
		     (no-debug-blocks-debug-function condition)))))

(define-condition no-debug-vars (debug-condition)
  ((debug-function :reader no-debug-vars-debug-function
		   :initarg :debug-function))
  #!+sb-doc
  (:documentation "The debug-function has no DEBUG-VAR information.")
  (:report (lambda (condition stream)
	     (format stream "~&~S has no debug variable information."
		     (no-debug-vars-debug-function condition)))))

(define-condition lambda-list-unavailable (debug-condition)
  ((debug-function :reader lambda-list-unavailable-debug-function
		   :initarg :debug-function))
  #!+sb-doc
  (:documentation
   "The debug-function has no lambda-list since argument DEBUG-VARs are
    unavailable.")
  (:report (lambda (condition stream)
	     (format stream "~&~S has no lambda-list information available."
		     (lambda-list-unavailable-debug-function condition)))))

(define-condition invalid-value (debug-condition)
  ((debug-var :reader invalid-value-debug-var :initarg :debug-var)
   (frame :reader invalid-value-frame :initarg :frame))
  (:report (lambda (condition stream)
	     (format stream "~&~S has :invalid or :unknown value in ~S."
		     (invalid-value-debug-var condition)
		     (invalid-value-frame condition)))))

(define-condition ambiguous-variable-name (debug-condition)
  ((name :reader ambiguous-variable-name-name :initarg :name)
   (frame :reader ambiguous-variable-name-frame :initarg :frame))
  (:report (lambda (condition stream)
	     (format stream "~&~S names more than one valid variable in ~S."
		     (ambiguous-variable-name-name condition)
		     (ambiguous-variable-name-frame condition)))))

;;;; errors and DEBUG-SIGNAL

;;; The debug-internals code tries to signal all programmer errors as
;;; subtypes of DEBUG-ERROR. There are calls to ERROR signalling
;;; SIMPLE-ERRORs, but these dummy checks in the code and shouldn't
;;; come up.
;;;
;;; While under development, this code also signals errors in code
;;; branches that remain unimplemented.

(define-condition debug-error (error) ()
  #!+sb-doc
  (:documentation
   "All programmer errors from using the interface for building debugging
    tools inherit from this type."))

(define-condition unhandled-debug-condition (debug-error)
  ((condition :reader unhandled-debug-condition-condition :initarg :condition))
  (:report (lambda (condition stream)
	     (format stream "~&unhandled DEBUG-CONDITION:~%~A"
		     (unhandled-debug-condition-condition condition)))))

(define-condition unknown-code-location (debug-error)
  ((code-location :reader unknown-code-location-code-location
		  :initarg :code-location))
  (:report (lambda (condition stream)
	     (format stream "~&invalid use of an unknown code-location: ~S"
		     (unknown-code-location-code-location condition)))))

(define-condition unknown-debug-var (debug-error)
  ((debug-var :reader unknown-debug-var-debug-var :initarg :debug-var)
   (debug-function :reader unknown-debug-var-debug-function
		   :initarg :debug-function))
  (:report (lambda (condition stream)
	     (format stream "~&~S is not in ~S."
		     (unknown-debug-var-debug-var condition)
		     (unknown-debug-var-debug-function condition)))))

(define-condition invalid-control-stack-pointer (debug-error)
  ()
  (:report (lambda (condition stream)
	     (declare (ignore condition))
	     (fresh-line stream)
	     (write-string "invalid control stack pointer" stream))))

(define-condition frame-function-mismatch (debug-error)
  ((code-location :reader frame-function-mismatch-code-location
		  :initarg :code-location)
   (frame :reader frame-function-mismatch-frame :initarg :frame)
   (form :reader frame-function-mismatch-form :initarg :form))
  (:report (lambda (condition stream)
	     (format
	      stream
	      "~&Form was preprocessed for ~S,~% but called on ~S:~%  ~S"
	      (frame-function-mismatch-code-location condition)
	      (frame-function-mismatch-frame condition)
	      (frame-function-mismatch-form condition)))))

;;; This signals debug-conditions. If they go unhandled, then signal
;;; an UNHANDLED-DEBUG-CONDITION error.
;;;
;;; ??? Get SIGNAL in the right package!
(defmacro debug-signal (datum &rest arguments)
  `(let ((condition (make-condition ,datum ,@arguments)))
     (signal condition)
     (error 'unhandled-debug-condition :condition condition)))

;;;; structures
;;;;
;;;; Most of these structures model information stored in internal
;;;; data structures created by the compiler. Whenever comments
;;;; preface an object or type with "compiler", they refer to the
;;;; internal compiler thing, not to the object or type with the same
;;;; name in the "DI" package.

;;;; DEBUG-VARs

;;; These exist for caching data stored in packed binary form in
;;; compiler debug-functions. Debug-functions store these.
(defstruct (debug-var (:constructor nil)
		      (:copier nil))
  ;; the name of the variable
  (symbol (required-argument) :type symbol)
  ;; a unique integer identification relative to other variables with the same
  ;; symbol
  (id 0 :type sb!c::index)
  ;; Does the variable always have a valid value?
  (alive-p nil :type boolean))
(def!method print-object ((debug-var debug-var) stream)
  (print-unreadable-object (debug-var stream :type t :identity t)
    (format stream
	    "~S ~D"
	    (debug-var-symbol debug-var)
	    (debug-var-id debug-var))))

#!+sb-doc
(setf (fdocumentation 'debug-var-id 'function)
  "Returns the integer that makes DEBUG-VAR's name and package unique
   with respect to other DEBUG-VARs in the same function.")

(defstruct (compiled-debug-var
	    (:include debug-var)
	    (:constructor make-compiled-debug-var
			  (symbol id alive-p sc-offset save-sc-offset))
	    (:copier nil))
  ;; Storage class and offset. (unexported).
  (sc-offset nil :type sb!c::sc-offset)
  ;; Storage class and offset when saved somewhere.
  (save-sc-offset nil :type (or sb!c::sc-offset null)))

(defstruct (interpreted-debug-var
	    (:include debug-var (alive-p t))
	    (:constructor make-interpreted-debug-var (symbol ir1-var))
	    (:copier nil))
  ;; This is the IR1 structure that holds information about interpreted vars.
  (ir1-var nil :type sb!c::lambda-var))

;;;; frames

;;; These represent call-frames on the stack.
(defstruct (frame (:constructor nil)
		  (:copier nil))
  ;; the next frame up, or NIL when top frame
  (up nil :type (or frame null))
  ;; the previous frame down, or NIL when the bottom frame. Before
  ;; computing the next frame down, this slot holds the frame pointer
  ;; to the control stack for the given frame. This lets us get the
  ;; next frame down and the return-pc for that frame.
  (%down :unparsed :type (or frame (member nil :unparsed)))
  ;; the debug-function for the function whose call this frame
  ;; represents
  (debug-function nil :type debug-function)
  ;; the code-location to continue upon return to frame
  (code-location nil :type code-location)
  ;; an a-list of catch-tags to code-locations
  (%catches :unparsed :type (or list (member :unparsed)))
  ;; pointer to frame on control stack. (unexported) When this frame
  ;; is an interpreted-frame, this pointer is an index into the
  ;; interpreter's stack.
  pointer
  ;; This is the frame's number for prompt printing. Top is zero.
  (number 0 :type index))

#!+sb-doc
(setf (fdocumentation 'frame-up 'function)
  "Returns the frame immediately above frame on the stack. When frame is
   the top of the stack, this returns nil.")

#!+sb-doc
(setf (fdocumentation 'frame-debug-function 'function)
  "Returns the debug-function for the function whose call frame represents.")

#!+sb-doc
(setf (fdocumentation 'frame-code-location 'function)
  "Returns the code-location where the frame's debug-function will continue
   running when program execution returns to this frame. If someone
   interrupted this frame, the result could be an unknown code-location.")

(defstruct (compiled-frame
	    (:include frame)
	    (:constructor make-compiled-frame
			  (pointer up debug-function code-location number
				   #!+gengc saved-state-chain
				   &optional escaped))
	    (:copier nil))
  ;; This indicates whether someone interrupted the frame.
  ;; (unexported). If escaped, this is a pointer to the state that was
  ;; saved when we were interrupted. On the non-gengc system, this is
  ;; a pointer to an os_context_t, i.e. the third argument to an
  ;; SA_SIGACTION-style signal handler. On the gengc system, this is a
  ;; state pointer from SAVED-STATE-CHAIN.
  escaped
  ;; a list of SAPs to saved states. Each time we unwind past an
  ;; exception, we pop the next entry off this list. When we get to
  ;; the end of the list, there is nothing else on the stack.
  #!+gengc (saved-state-chain nil :type list))
(def!method print-object ((obj compiled-frame) str)
  (print-unreadable-object (obj str :type t)
    (format str
	    "~S~:[~;, interrupted~]"
	    (debug-function-name (frame-debug-function obj))
	    (compiled-frame-escaped obj))))

(defstruct (interpreted-frame
	    (:include frame)
	    (:constructor make-interpreted-frame
			  (pointer up debug-function code-location number
			   real-frame closure))
	    (:copier nil))
  ;; This points to the compiled-frame for SB!EVAL:INTERNAL-APPLY-LOOP.
  (real-frame nil :type compiled-frame)
  ;; This is the closed over data used by the interpreter.
  (closure nil :type simple-vector))
(def!method print-object ((obj interpreted-frame) str)
  (print-unreadable-object (obj str :type t)
    (prin1 (debug-function-name (frame-debug-function obj)) str)))

;;;; DEBUG-FUNCTIONs

;;; These exist for caching data stored in packed binary form in
;;; compiler debug-functions. *COMPILED-DEBUG-FUNCTIONS* maps a
;;; SB!C::DEBUG-FUNCTION to a DEBUG-FUNCTION. There should only be one
;;; DEBUG-FUNCTION in existence for any function; that is, all
;;; code-locations and other objects that reference DEBUG-FUNCTIONs
;;; point to unique objects. This is due to the overhead in cached
;;; information.
(defstruct (debug-function (:copier nil))
  ;; Some representation of the function arguments. See
  ;; DEBUG-FUNCTION-LAMBDA-LIST.
  ;; NOTE: must parse vars before parsing arg list stuff.
  (%lambda-list :unparsed)
  ;; Cached DEBUG-VARS information. (unexported).
  ;; These are sorted by their name.
  (%debug-vars :unparsed :type (or simple-vector null (member :unparsed)))
  ;; Cached debug-block information. This is NIL when we have tried to
  ;; parse the packed binary info, but none is available.
  (blocks :unparsed :type (or simple-vector null (member :unparsed)))
  ;; The actual function if available.
  (%function :unparsed :type (or null function (member :unparsed))))
(def!method print-object ((obj debug-function) stream)
  (print-unreadable-object (obj stream :type t)
    (prin1 (debug-function-name obj) stream)))

(defstruct (compiled-debug-function
	    (:include debug-function)
	    (:constructor %make-compiled-debug-function
			  (compiler-debug-fun component))
	    (:copier nil))
  ;; Compiler's dumped debug-function information. (unexported).
  (compiler-debug-fun nil :type sb!c::compiled-debug-function)
  ;; Code object. (unexported).
  component
  ;; The :FUNCTION-START breakpoint (if any) used to facilitate
  ;; function end breakpoints.
  (end-starter nil :type (or null breakpoint)))

;;; This maps SB!C::COMPILED-DEBUG-FUNCTIONs to
;;; COMPILED-DEBUG-FUNCTIONs, so we can get at cached stuff and not
;;; duplicate COMPILED-DEBUG-FUNCTION structures.
(defvar *compiled-debug-functions* (make-hash-table :test 'eq))

;;; Make a COMPILED-DEBUG-FUNCTION for a SB!C::COMPILER-DEBUG-FUNCTION
;;; and its component. This maps the latter to the former in
;;; *COMPILED-DEBUG-FUNCTIONS*. If there already is a
;;; COMPILED-DEBUG-FUNCTION, then this returns it from
;;; *COMPILED-DEBUG-FUNCTIONS*.
(defun make-compiled-debug-function (compiler-debug-fun component)
  (or (gethash compiler-debug-fun *compiled-debug-functions*)
      (setf (gethash compiler-debug-fun *compiled-debug-functions*)
	    (%make-compiled-debug-function compiler-debug-fun component))))

(defstruct (interpreted-debug-function
	    (:include debug-function)
	    (:constructor %make-interpreted-debug-function (ir1-lambda))
	    (:copier nil))
  ;; This is the IR1 lambda that this debug-function represents.
  (ir1-lambda nil :type sb!c::clambda))

(defstruct (bogus-debug-function
	    (:include debug-function)
	    (:constructor make-bogus-debug-function
			  (%name &aux (%lambda-list nil) (%debug-vars nil)
				 (blocks nil) (%function nil)))
	    (:copier nil))
  %name)

(defvar *ir1-lambda-debug-function* (make-hash-table :test 'eq))

(defun make-interpreted-debug-function (ir1-lambda)
  (let ((home-lambda (sb!c::lambda-home ir1-lambda)))
    (or (gethash home-lambda *ir1-lambda-debug-function*)
	(setf (gethash home-lambda *ir1-lambda-debug-function*)
	      (%make-interpreted-debug-function home-lambda)))))

;;;; DEBUG-BLOCKs

;;; These exist for caching data stored in packed binary form in compiler
;;; DEBUG-BLOCKs.
(defstruct (debug-block (:constructor nil)
			(:copier nil))
  ;; Code-locations where execution continues after this block.
  (successors nil :type list)
  ;; This indicates whether the block is a special glob of code shared by
  ;; various functions and tucked away elsewhere in a component. This kind of
  ;; block has no start code-location. In an interpreted-debug-block, this is
  ;; always nil. This slot is in all debug-blocks since it is an exported
  ;; interface.
  (elsewhere-p nil :type boolean))
(def!method print-object ((obj debug-block) str)
  (print-unreadable-object (obj str :type t)
    (prin1 (debug-block-function-name obj) str)))

#!+sb-doc
(setf (fdocumentation 'debug-block-successors 'function)
  "Returns the list of possible code-locations where execution may continue
   when the basic-block represented by debug-block completes its execution.")

#!+sb-doc
(setf (fdocumentation 'debug-block-elsewhere-p 'function)
  "Returns whether debug-block represents elsewhere code.")

(defstruct (compiled-debug-block (:include debug-block)
				 (:constructor
				  make-compiled-debug-block
				  (code-locations successors elsewhere-p))
				 (:copier nil))
  ;; code-location information for the block
  (code-locations nil :type simple-vector))

(defstruct (interpreted-debug-block (:include debug-block
					      (elsewhere-p nil))
				    (:constructor %make-interpreted-debug-block
						  (ir1-block))
				    (:copier nil))
  ;; This is the IR1 block this debug-block represents.
  (ir1-block nil :type sb!c::cblock)
  ;; Code-location information for the block.
  (locations :unparsed :type (or (member :unparsed) simple-vector)))

(defvar *ir1-block-debug-block* (make-hash-table :test 'eq))

;;; Make a DEBUG-BLOCK for the interpreter's IR1-BLOCK. If we have it
;;; in the cache, return it. If we need to make it, then first make
;;; DEBUG-BLOCKs for all the IR1-BLOCKs in IR1-BLOCK's home lambda;
;;; this makes sure all the successors of IR1-BLOCK have DEBUG-BLOCKs.
;;; We need this to fill in the resulting DEBUG-BLOCK's successors
;;; list with DEBUG-BLOCKs, not IR1-BLOCKs. After making all the
;;; possible DEBUG-BLOCKs we'll need to reference, go back over the
;;; list of new DEBUG-BLOCKs and fill in their successor slots with
;;; lists of DEBUG-BLOCKs. Then look up our argument IR1-BLOCK to find
;;; its DEBUG-BLOCK since we know we have it now.
(defun make-interpreted-debug-block (ir1-block)
  (check-type ir1-block sb!c::cblock)
  (let ((res (gethash ir1-block *ir1-block-debug-block*)))
    (or res
	(let ((lambda (sb!c::block-home-lambda ir1-block)))
	  (sb!c::do-blocks (block (sb!c::block-component ir1-block))
	    (when (eq lambda (sb!c::block-home-lambda block))
	      (push (setf (gethash block *ir1-block-debug-block*)
			  (%make-interpreted-debug-block block))
		    res)))
	  (dolist (block res)
	    (let* ((successors nil)
		   (cblock (interpreted-debug-block-ir1-block block))
		   (succ (sb!c::block-succ cblock))
		   (valid-succ
		    (if (and succ
			     (eq (car succ)
				 (sb!c::component-tail
				  (sb!c::block-component cblock))))
			()
			succ)))
	      (dolist (sblock valid-succ)
		(let ((dblock (gethash sblock *ir1-block-debug-block*)))
		  (when dblock
		    (push dblock successors))))
	      (setf (debug-block-successors block) (nreverse successors))))
	  (gethash ir1-block *ir1-block-debug-block*)))))

;;;; breakpoints

;;; This is an internal structure that manages information about a
;;; breakpoint locations. See *COMPONENT-BREAKPOINT-OFFSETS*.
(defstruct (breakpoint-data (:constructor make-breakpoint-data
					  (component offset))
			    (:copier nil))
  ;; This is the component in which the breakpoint lies.
  component
  ;; This is the byte offset into the component.
  (offset nil :type sb!c::index)
  ;; The original instruction replaced by the breakpoint.
  (instruction nil :type (or null (unsigned-byte 32)))
  ;; A list of user breakpoints at this location.
  (breakpoints nil :type list))
(def!method print-object ((obj breakpoint-data) str)
  (print-unreadable-object (obj str :type t)
    (format str "~S at ~S"
	    (debug-function-name
	     (debug-function-from-pc (breakpoint-data-component obj)
				     (breakpoint-data-offset obj)))
	    (breakpoint-data-offset obj))))

(defstruct (breakpoint (:constructor %make-breakpoint
				     (hook-function what kind %info))
		       (:copier nil))
  ;; This is the function invoked when execution encounters the
  ;; breakpoint. It takes a frame, the breakpoint, and optionally a
  ;; list of values. Values are supplied for :FUNCTION-END breakpoints
  ;; as values to return for the function containing the breakpoint.
  ;; :FUNCTION-END breakpoint hook-functions also take a cookie
  ;; argument. See COOKIE-FUN slot.
  (hook-function nil :type function)
  ;; CODE-LOCATION or DEBUG-FUNCTION
  (what nil :type (or code-location debug-function))
  ;; :CODE-LOCATION, :FUNCTION-START, or :FUNCTION-END for that kind
  ;; of breakpoint. :UNKNOWN-RETURN-PARTNER if this is the partner of
  ;; a :code-location breakpoint at an :UNKNOWN-RETURN code-location.
  (kind nil :type (member :code-location :function-start :function-end
			  :unknown-return-partner))
  ;; Status helps the user and the implementation.
  (status :inactive :type (member :active :inactive :deleted))
  ;; This is a backpointer to a breakpoint-data.
  (internal-data nil :type (or null breakpoint-data))
  ;; With code-locations whose type is :UNKNOWN-RETURN, there are
  ;; really two breakpoints: one at the multiple-value entry point,
  ;; and one at the single-value entry point. This slot holds the
  ;; breakpoint for the other one, or NIL if this isn't at an
  ;; :UNKNOWN-RETURN code location.
  (unknown-return-partner nil :type (or null breakpoint))
  ;; :FUNCTION-END breakpoints use a breakpoint at the :FUNCTION-START
  ;; to establish the end breakpoint upon function entry. We do this
  ;; by frobbing the LRA to jump to a special piece of code that
  ;; breaks and provides the return values for the returnee. This slot
  ;; points to the start breakpoint, so we can activate, deactivate,
  ;; and delete it.
  (start-helper nil :type (or null breakpoint))
  ;; This is a hook users supply to get a dynamically unique cookie
  ;; for identifying :FUNCTION-END breakpoint executions. That is, if
  ;; there is one :FUNCTION-END breakpoint, but there may be multiple
  ;; pending calls of its function on the stack. This function takes
  ;; the cookie, and the hook-function takes the cookie too.
  (cookie-fun nil :type (or null function))
  ;; This slot users can set with whatever information they find useful.
  %info)
(def!method print-object ((obj breakpoint) str)
  (let ((what (breakpoint-what obj)))
    (print-unreadable-object (obj str :type t)
      (format str
	      "~S~:[~;~:*~S~]"
	      (etypecase what
		(code-location what)
		(debug-function (debug-function-name what)))
	      (etypecase what
		(code-location nil)
		(debug-function (breakpoint-kind obj)))))))

#!+sb-doc
(setf (fdocumentation 'breakpoint-hook-function 'function)
  "Returns the breakpoint's function the system calls when execution encounters
   the breakpoint, and it is active. This is SETF'able.")

#!+sb-doc
(setf (fdocumentation 'breakpoint-what 'function)
  "Returns the breakpoint's what specification.")

#!+sb-doc
(setf (fdocumentation 'breakpoint-kind 'function)
  "Returns the breakpoint's kind specification.")

;;;; CODE-LOCATIONs

(defstruct (code-location (:constructor nil)
			  (:copier nil))
  ;; This is the debug-function containing code-location.
  (debug-function nil :type debug-function)
  ;; This is initially :UNSURE. Upon first trying to access an
  ;; :unparsed slot, if the data is unavailable, then this becomes t,
  ;; and the code-location is unknown. If the data is available, this
  ;; becomes nil, a known location. We can't use a separate type
  ;; code-location for this since we must return code-locations before
  ;; we can tell whether they're known or unknown. For example, when
  ;; parsing the stack, we don't want to unpack all the variables and
  ;; blocks just to make frames.
  (%unknown-p :unsure :type (member t nil :unsure))
  ;; This is the debug-block containing code-location. Possibly toss
  ;; this out and just find it in the blocks cache in debug-function.
  (%debug-block :unparsed :type (or debug-block (member :unparsed)))
  ;; This is the number of forms processed by the compiler or loader
  ;; before the top-level form containing this code-location.
  (%tlf-offset :unparsed :type (or sb!c::index (member :unparsed)))
  ;; This is the depth-first number of the node that begins
  ;; code-location within its top-level form.
  (%form-number :unparsed :type (or sb!c::index (member :unparsed))))
(def!method print-object ((obj code-location) str)
  (print-unreadable-object (obj str :type t)
    (prin1 (debug-function-name (code-location-debug-function obj))
	   str)))

#!+sb-doc
(setf (fdocumentation 'code-location-debug-function 'function)
  "Returns the debug-function representing information about the function
   corresponding to the code-location.")

(defstruct (compiled-code-location
	    (:include code-location)
	    (:constructor make-known-code-location
			  (pc debug-function %tlf-offset %form-number
			      %live-set kind &aux (%unknown-p nil)))
	    (:constructor make-compiled-code-location (pc debug-function))
	    (:copier nil))
  ;; This is an index into debug-function's component slot.
  (pc nil :type sb!c::index)
  ;; This is a bit-vector indexed by a variable's position in
  ;; DEBUG-FUNCTION-DEBUG-VARS indicating whether the variable has a
  ;; valid value at this code-location. (unexported).
  (%live-set :unparsed :type (or simple-bit-vector (member :unparsed)))
  ;; (unexported) To see SB!C::LOCATION-KIND, do
  ;; (SB!KERNEL:TYPE-EXPAND 'SB!C::LOCATION-KIND).
  (kind :unparsed :type (or (member :unparsed) sb!c::location-kind)))

(defstruct (interpreted-code-location
	    (:include code-location
		      (%unknown-p nil))
	    (:constructor make-interpreted-code-location
			  (ir1-node debug-function))
	    (:copier nil))
  ;; This is an index into debug-function's component slot.
  (ir1-node nil :type sb!c::node))

;;; DEBUG-SOURCEs

#!-sb-fluid (declaim (inline debug-source-root-number))
(defun debug-source-root-number (debug-source)
  #!+sb-doc
  "Returns the number of top-level forms processed by the compiler before
   compiling this source. If this source is uncompiled, this is zero. This
   may be zero even if the source is compiled since the first form in the first
   file compiled in one compilation, for example, must have a root number of
   zero -- the compiler saw no other top-level forms before it."
  (sb!c::debug-source-source-root debug-source))

#!+sb-doc
(setf (fdocumentation 'sb!c::debug-source-from 'function)
  "Returns an indication of the type of source. The following are the possible
   values:
      :file    from a file (obtained by COMPILE-FILE if compiled).
      :lisp    from Lisp (obtained by COMPILE if compiled).")

#!+sb-doc
(setf (fdocumentation 'sb!c::debug-source-name 'function)
  "Returns the actual source in some sense represented by debug-source, which
   is related to DEBUG-SOURCE-FROM:
      :file    the pathname of the file.
      :lisp    a lambda-expression.")

#!+sb-doc
(setf (fdocumentation 'sb!c::debug-source-created 'function)
  "Returns the universal time someone created the source. This may be nil if
   it is unavailable.")

#!+sb-doc
(setf (fdocumentation 'sb!c::debug-source-compiled 'function)
  "Returns the time someone compiled the source. This is nil if the source
   is uncompiled.")

#!+sb-doc
(setf (fdocumentation 'sb!c::debug-source-start-positions 'function)
  "This function returns the file position of each top-level form as an array
   if debug-source is from a :file. If DEBUG-SOURCE-FROM is :lisp,
   this returns nil.")

#!+sb-doc
(setf (fdocumentation 'sb!c::debug-source-p 'function)
  "Returns whether object is a debug-source.")

;;;; frames

;;; This is used in FIND-ESCAPE-FRAME and with the bogus components
;;; and LRAs used for :function-end breakpoints. When a components
;;; debug-info slot is :bogus-lra, then the real-lra-slot contains the
;;; real component to continue executing, as opposed to the bogus
;;; component which appeared in some frame's LRA location.
(defconstant real-lra-slot sb!vm:code-constants-offset)

;;; These are magically converted by the compiler.
(defun current-sp () (current-sp))
(defun current-fp () (current-fp))
(defun stack-ref (s n) (stack-ref s n))
(defun %set-stack-ref (s n value) (%set-stack-ref s n value))
(defun function-code-header (fun) (function-code-header fun))
#!-gengc (defun lra-code-header (lra) (lra-code-header lra))
(defun make-lisp-obj (value) (make-lisp-obj value))
(defun get-lisp-obj-address (thing) (get-lisp-obj-address thing))
(defun function-word-offset (fun) (function-word-offset fun))

#!-sb-fluid (declaim (inline cstack-pointer-valid-p))
(defun cstack-pointer-valid-p (x)
  (declare (type system-area-pointer x))
  #!-x86 ; stack grows toward high address values
  (and (sap< x (current-sp))
       (sap<= #!-gengc (int-sap control-stack-start)
	      #!+gengc (mutator-control-stack-base)
	      x)
       (zerop (logand (sap-int x) #b11)))
  #!+x86 ; stack grows toward low address values
  (and (sap>= x (current-sp))
       (sap> (int-sap control-stack-end) x)
       (zerop (logand (sap-int x) #b11))))

#!+(or gengc x86)
(sb!alien:def-alien-routine component-ptr-from-pc (system-area-pointer)
  (pc system-area-pointer))

#!+(or gengc x86)
(defun component-from-component-ptr (component-ptr)
  (declare (type system-area-pointer component-ptr))
  (make-lisp-obj (logior (sap-int component-ptr)
			 sb!vm:other-pointer-type)))

;;;; X86 support

#!+x86
(progn

(defun compute-lra-data-from-pc (pc)
  (declare (type system-area-pointer pc))
  (let ((component-ptr (component-ptr-from-pc pc)))
    (unless (sap= component-ptr (int-sap #x0))
       (let* ((code (component-from-component-ptr component-ptr))
	      (code-header-len (* (get-header-data code) sb!vm:word-bytes))
	      (pc-offset (- (sap-int pc)
			    (- (get-lisp-obj-address code)
			       sb!vm:other-pointer-type)
			    code-header-len)))
;	 (format t "c-lra-fpc ~A ~A ~A~%" pc code pc-offset)
	 (values pc-offset code)))))

(defconstant sb!vm::nargs-offset #.sb!vm::ecx-offset)

;;; Check for a valid return address - it could be any valid C/Lisp
;;; address.
;;;
;;; XXX Could be a little smarter.
#!-sb-fluid (declaim (inline ra-pointer-valid-p))
(defun ra-pointer-valid-p (ra)
  (declare (type system-area-pointer ra))
  (and
   ;; Not the first page which is unmapped.
   (>= (sap-int ra) 4096)
   ;; Not a Lisp stack pointer.
   (not (cstack-pointer-valid-p ra))))

;;; Try to find a valid previous stack. This is complex on the x86 as
;;; it can jump between C and Lisp frames. To help find a valid frame
;;; it searches backwards.
;;;
;;; XXX Should probably check whether it has reached the bottom of the
;;; stack.
;;;
;;; XXX Should handle interrupted frames, both Lisp and C. At present
;;; it manages to find a fp trail, see linux hack below.
(defun x86-call-context (fp &key (depth 0))
  (declare (type system-area-pointer fp)
	   (fixnum depth))
  ;;(format t "*CC ~S ~S~%" fp depth)
  (cond
   ((not (cstack-pointer-valid-p fp))
    #+nil (format t "debug invalid fp ~S~%" fp)
    nil)
   (t
    ;; Check the two possible frame pointers.
    (let ((lisp-ocfp (sap-ref-sap fp (- (* (1+ sb!vm::ocfp-save-offset) 4))))
	  (lisp-ra (sap-ref-sap fp (- (* (1+ sb!vm::return-pc-save-offset)
					 4))))
	  (c-ocfp (sap-ref-sap fp (* 0 sb!vm:word-bytes)))
	  (c-ra (sap-ref-sap fp (* 1 sb!vm:word-bytes))))
      (cond ((and (sap> lisp-ocfp fp) (cstack-pointer-valid-p lisp-ocfp)
		  (ra-pointer-valid-p lisp-ra)
		  (sap> c-ocfp fp) (cstack-pointer-valid-p c-ocfp)
		  (ra-pointer-valid-p c-ra))
	     #+nil (format t
			   "*C Both valid ~S ~S ~S ~S~%"
			   lisp-ocfp lisp-ra c-ocfp c-ra)
	     ;; Look forward another step to check their validity.
	     (let ((lisp-path-fp (x86-call-context lisp-ocfp
						   :depth (1+ depth)))
		   (c-path-fp (x86-call-context c-ocfp :depth (1+ depth))))
	       (cond ((and lisp-path-fp c-path-fp)
                       ;; Both still seem valid - choose the lisp frame.
                       #+nil (when (zerop depth)
                               (format t
				       "debug: both still valid ~S ~S ~S ~S~%"
                                       lisp-ocfp lisp-ra c-ocfp c-ra))
		      #+freebsd
		      (if (sap> lisp-ocfp c-ocfp)
                        (values lisp-ra lisp-ocfp)
			(values c-ra c-ocfp))
                       #-freebsd
                       (values lisp-ra lisp-ocfp))
		     (lisp-path-fp
		      ;; The lisp convention is looking good.
		      #+nil (format t "*C lisp-ocfp ~S ~S~%" lisp-ocfp lisp-ra)
		      (values lisp-ra lisp-ocfp))
		     (c-path-fp
		      ;; The C convention is looking good.
		      #+nil (format t "*C c-ocfp ~S ~S~%" c-ocfp c-ra)
		      (values c-ra c-ocfp))
		     (t
		      ;; Neither seems right?
		      #+nil (format t "debug: no valid2 fp found ~S ~S~%"
				    lisp-ocfp c-ocfp)
		      nil))))
	    ((and (sap> lisp-ocfp fp) (cstack-pointer-valid-p lisp-ocfp)
		  (ra-pointer-valid-p lisp-ra))
	     ;; The lisp convention is looking good.
	     #+nil (format t "*C lisp-ocfp ~S ~S~%" lisp-ocfp lisp-ra)
	     (values lisp-ra lisp-ocfp))
	    ((and (sap> c-ocfp fp) (cstack-pointer-valid-p c-ocfp)
		  #!-linux (ra-pointer-valid-p c-ra))
	     ;; The C convention is looking good.
	     #+nil (format t "*C c-ocfp ~S ~S~%" c-ocfp c-ra)
	     (values c-ra c-ocfp))
	    (t
	     #+nil (format t "debug: no valid fp found ~S ~S~%"
			   lisp-ocfp c-ocfp)
	     nil))))))

) ; #+x86 PROGN

;;; Convert the descriptor into a SAP. The bits all stay the same, we just
;;; change our notion of what we think they are.
#!-sb-fluid (declaim (inline descriptor-sap))
(defun descriptor-sap (x)
  (int-sap (get-lisp-obj-address x)))

(defun top-frame ()
  #!+sb-doc
  "Returns the top frame of the control stack as it was before calling this
   function."
  (multiple-value-bind (fp pc) (%caller-frame-and-pc)
    (possibly-an-interpreted-frame
     (compute-calling-frame (descriptor-sap fp)
			    #!-gengc pc #!+gengc (descriptor-sap pc)
			    nil)
     nil)))

(defun flush-frames-above (frame)
  #!+sb-doc
  "Flush all of the frames above FRAME, and renumber all the frames below
   FRAME."
  (setf (frame-up frame) nil)
  (do ((number 0 (1+ number))
       (frame frame (frame-%down frame)))
      ((not (frame-p frame)))
    (setf (frame-number frame) number)))

;;; We have to access the old-fp and return-pc out of frame and pass them to
;;; COMPUTE-CALLING-FRAME.
(defun frame-down (frame)
  #!+sb-doc
  "Returns the frame immediately below frame on the stack. When frame is
   the bottom of the stack, this returns nil."
  (let ((down (frame-%down frame)))
    (if (eq down :unparsed)
	(let* ((real (frame-real-frame frame))
	       (debug-fun (frame-debug-function real)))
	  (setf (frame-%down frame)
		(etypecase debug-fun
		  (compiled-debug-function
		   (let ((c-d-f (compiled-debug-function-compiler-debug-fun
				 debug-fun)))
		     (possibly-an-interpreted-frame
		      (compute-calling-frame
		       (descriptor-sap
			(get-context-value
			 real sb!vm::ocfp-save-offset
			 (sb!c::compiled-debug-function-old-fp c-d-f)))
		       #!-gengc
		       (get-context-value
			real sb!vm::lra-save-offset
			(sb!c::compiled-debug-function-return-pc c-d-f))
		       #!+gengc
		       (descriptor-sap
			(get-context-value
			 real sb!vm::ra-save-offset
			 (sb!c::compiled-debug-function-return-pc c-d-f)))
		       frame)
		      frame)))
		  (bogus-debug-function
		   (let ((fp (frame-pointer real)))
		     (when (cstack-pointer-valid-p fp)
		       #!+x86
			(multiple-value-bind (ra ofp) (x86-call-context fp)
			  (compute-calling-frame ofp ra frame))
			#!-x86
		       (compute-calling-frame
			#!-alpha
			(sap-ref-sap fp (* sb!vm::ocfp-save-offset
					   sb!vm:word-bytes))
			#!+alpha
			(int-sap
			 (sap-ref-32 fp (* sb!vm::ocfp-save-offset
					   sb!vm:word-bytes)))

			#!-gengc
			(stack-ref fp sb!vm::lra-save-offset)
			#!+gengc
			(sap-ref-sap fp (* sb!vm::ra-save-offset
					   sb!vm:word-bytes))
			frame)))))))
	down)))

;;; Get the old FP or return PC out of FRAME. STACK-SLOT is the
;;; standard save location offset on the stack. LOC is the saved
;;; SC-OFFSET describing the main location.
#!-x86
(defun get-context-value (frame stack-slot loc)
  (declare (type compiled-frame frame) (type unsigned-byte stack-slot)
	   (type sb!c::sc-offset loc))
  (let ((pointer (frame-pointer frame))
	(escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-access-debug-var-slot pointer loc escaped)
	(stack-ref pointer stack-slot))))
#!+x86
(defun get-context-value (frame stack-slot loc)
  (declare (type compiled-frame frame) (type unsigned-byte stack-slot)
	   (type sb!c::sc-offset loc))
  (let ((pointer (frame-pointer frame))
	(escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-access-debug-var-slot pointer loc escaped)
	(ecase stack-slot
	  (#.sb!vm::ocfp-save-offset
	   (stack-ref pointer stack-slot))
	  (#.sb!vm::lra-save-offset
	   (sap-ref-sap pointer (- (* (1+ stack-slot) 4))))))))

#!-x86
(defun (setf get-context-value) (value frame stack-slot loc)
  (declare (type compiled-frame frame) (type unsigned-byte stack-slot)
	   (type sb!c::sc-offset loc))
  (let ((pointer (frame-pointer frame))
	(escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-set-debug-var-slot pointer loc value escaped)
	(setf (stack-ref pointer stack-slot) value))))

#!+x86
(defun (setf get-context-value) (value frame stack-slot loc)
  (declare (type compiled-frame frame) (type unsigned-byte stack-slot)
	   (type sb!c::sc-offset loc))
  (let ((pointer (frame-pointer frame))
	(escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-set-debug-var-slot pointer loc value escaped)
	(ecase stack-slot
	  (#.sb!vm::ocfp-save-offset
	   (setf (stack-ref pointer stack-slot) value))
	  (#.sb!vm::lra-save-offset
	   (setf (sap-ref-sap pointer (- (* (1+ stack-slot) 4))) value))))))

(defvar *debugging-interpreter* nil
  #!+sb-doc
  "When set, the debugger foregoes making interpreted-frames, so you can
   debug the functions that manifest the interpreter.")

;;; This takes a newly computed frame, FRAME, and the frame above it
;;; on the stack, UP-FRAME, which is possibly NIL. FRAME is NIL when
;;; we hit the bottom of the control stack. When FRAME represents a
;;; call to SB!EVAL::INTERNAL-APPLY-LOOP, we make an interpreted frame
;;; to replace FRAME. The interpreted frame points to FRAME.
(defun possibly-an-interpreted-frame (frame up-frame)
  (if (or (not frame)
	  (not (eq (debug-function-name (frame-debug-function frame))
		   'sb!eval::internal-apply-loop))
	  *debugging-interpreter*
	  (compiled-frame-escaped frame))
      frame
      (flet ((get-var (name location)
	       (let ((vars (sb!di:ambiguous-debug-vars
			    (sb!di:frame-debug-function frame) name)))
		 (when (or (null vars) (> (length vars) 1))
		   (error "zero or more than one ~A variable in ~
			   SB!EVAL::INTERNAL-APPLY-LOOP"
			  (string-downcase name)))
		 (if (eq (debug-var-validity (car vars) location)
			 :valid)
		     (car vars)))))
	(let* ((code-loc (frame-code-location frame))
	       (ptr-var (get-var "FRAME-PTR" code-loc))
	       (node-var (get-var "NODE" code-loc))
	       (closure-var (get-var "CLOSURE" code-loc)))
	  (if (and ptr-var node-var closure-var)
	      (let* ((node (debug-var-value node-var frame))
		     (d-fun (make-interpreted-debug-function
			     (sb!c::block-home-lambda (sb!c::node-block
						       node)))))
		(make-interpreted-frame
		 (debug-var-value ptr-var frame)
		 up-frame
		 d-fun
		 (make-interpreted-code-location node d-fun)
		 (frame-number frame)
		 frame
		 (debug-var-value closure-var frame)))
	      frame)))))

;;; This returns a frame for the one existing in time immediately
;;; prior to the frame referenced by current-fp. This is current-fp's
;;; caller or the next frame down the control stack. If there is no
;;; down frame, this returns nil for the bottom of the stack. Up-frame
;;; is the up link for the resulting frame object, and it is nil when
;;; we call this to get the top of the stack.
;;;
;;; The current frame contains the pointer to the temporally previous
;;; frame we want, and the current frame contains the pc at which we
;;; will continue executing upon returning to that previous frame.
;;;
;;; Note: Sometimes LRA is actually a fixnum. This happens when lisp
;;; calls into C. In this case, the code object is stored on the stack
;;; after the LRA, and the LRA is the word offset.
#!-(or gengc x86)
(defun compute-calling-frame (caller lra up-frame)
  (declare (type system-area-pointer caller))
  (when (cstack-pointer-valid-p caller)
    (multiple-value-bind (code pc-offset escaped)
	(if lra
	    (multiple-value-bind (word-offset code)
		(if (fixnump lra)
		    (let ((fp (frame-pointer up-frame)))
		      (values lra
			      (stack-ref fp (1+ sb!vm::lra-save-offset))))
		    (values (get-header-data lra)
			    (lra-code-header lra)))
	      (if code
		  (values code
			  (* (1+ (- word-offset (get-header-data code)))
			     sb!vm:word-bytes)
			  nil)
		  (values :foreign-function
			  0
			  nil)))
	    (find-escaped-frame caller))
      (if (and (code-component-p code)
	       (eq (%code-debug-info code) :bogus-lra))
	  (let ((real-lra (code-header-ref code real-lra-slot)))
	    (compute-calling-frame caller real-lra up-frame))
	  (let ((d-fun (case code
			 (:undefined-function
			  (make-bogus-debug-function
			   "undefined function"))
			 (:foreign-function
			  (make-bogus-debug-function
			   "foreign function call land"))
			 ((nil)
			  (make-bogus-debug-function
			   "bogus stack frame"))
			 (t
			  (debug-function-from-pc code pc-offset)))))
	    (make-compiled-frame caller up-frame d-fun
				 (code-location-from-pc d-fun pc-offset
							escaped)
				 (if up-frame (1+ (frame-number up-frame)) 0)
				 escaped))))))

#!+x86
(defun compute-calling-frame (caller ra up-frame)
  (declare (type system-area-pointer caller ra))
;  (format t "ccf: ~A ~A ~A~%" caller ra up-frame)
  (when (cstack-pointer-valid-p caller)
;    (format t "ccf2~%")
    ;; First check for an escaped frame.
    (multiple-value-bind (code pc-offset escaped) (find-escaped-frame caller)
	(cond (code
	       ;; If it's escaped it may be a function end breakpoint trap.
;	       (format t "ccf2: escaped ~S ~S~%" code pc-offset)
	       (when (and (code-component-p code)
			  (eq (%code-debug-info code) :bogus-lra))
		 ;; If :bogus-lra grab the real lra.
		 (setq pc-offset (code-header-ref
				  code (1+ real-lra-slot)))
		 (setq code (code-header-ref code real-lra-slot))
;		 (format t "ccf3 :bogus-lra ~S ~S~%" code pc-offset)
		 (aver code)))
	      (t
	       ;; Not escaped
	       (multiple-value-setq (pc-offset code)
		 (compute-lra-data-from-pc ra))
;	       (format t "ccf4 ~S ~S~%" code pc-offset)
	       (unless code
		 (setf code :foreign-function
		       pc-offset 0
		       escaped nil))))

	(let ((d-fun (case code
			   (:undefined-function
			    (make-bogus-debug-function
			     "undefined function"))
			   (:foreign-function
			    (make-bogus-debug-function
			     "foreign function call land"))
			   ((nil)
			    (make-bogus-debug-function
			     "bogus stack frame"))
			   (t
			    (debug-function-from-pc code pc-offset)))))
	  (make-compiled-frame caller up-frame d-fun
			       (code-location-from-pc d-fun pc-offset
						      escaped)
			       (if up-frame (1+ (frame-number up-frame)) 0)
			       escaped)))))

#!-(or gengc x86)
;;; FIXME: The original CMU CL code had support for this case, but it
;;; must have been fairly stale even in CMU CL, since it had
;;; references to the MIPS package, and there have been enough
;;; relevant changes in SBCL (particularly using
;;; POSIX/SIGACTION0-style signal context instead of BSD-style
;;; sigcontext) that this code is unmaintainable (since as of
;;; sbcl-0.6.7, and for the foreseeable future, we can't test it,
;;; since we only support X86 and its gencgc).
;;;
;;; If we restore this case, the best approach would be to go back to
;;; the original CMU CL code and start from there.
(eval-when (:compile-toplevel :load-toplevel :execute)
  (error "hopelessly stale"))
#!+x86
(defun find-escaped-frame (frame-pointer)
  (declare (type system-area-pointer frame-pointer))
  (dotimes (index sb!impl::*free-interrupt-context-index* (values nil 0 nil))
    (sb!alien:with-alien
	((lisp-interrupt-contexts (array (* os-context-t) nil)
				  :extern))
      (let ((context (sb!alien:deref lisp-interrupt-contexts index)))
	(when (= (sap-int frame-pointer)
		 (sb!vm:context-register context sb!vm::cfp-offset))
	  (without-gcing
	   (let* ((component-ptr (component-ptr-from-pc
				  (sb!vm:context-pc context)))
		  (code (unless (sap= component-ptr (int-sap #x0))
			  (component-from-component-ptr component-ptr))))
	     (when (null code)
	       (return (values code 0 context)))
	     (let* ((code-header-len (* (get-header-data code)
					sb!vm:word-bytes))
		    (pc-offset
		     (- (sap-int (sb!vm:context-pc context))
			(- (get-lisp-obj-address code)
			   sb!vm:other-pointer-type)
			code-header-len)))
	       (unless (<= 0 pc-offset
			   (* (code-header-ref code sb!vm:code-code-size-slot)
			      sb!vm:word-bytes))
		 ;; We were in an assembly routine. Therefore, use the
		 ;; LRA as the pc.
		 ;;
		 ;; FIXME: Should this be WARN or ERROR or what?
		 (format t "** pc-offset ~S not in code obj ~S?~%"
			 pc-offset code))
	       (return
		(values code pc-offset context))))))))))

;;; Find the code object corresponding to the object represented by
;;; bits and return it. We assume bogus functions correspond to the
;;; undefined-function.
#!-gengc
(defun code-object-from-bits (bits)
  (declare (type (unsigned-byte 32) bits))
  (let ((object (make-lisp-obj bits)))
    (if (functionp object)
	(or (function-code-header object)
	    :undefined-function)
	(let ((lowtag (get-lowtag object)))
	  (if (= lowtag sb!vm:other-pointer-type)
	      (let ((type (get-type object)))
		(cond ((= type sb!vm:code-header-type)
		       object)
		      ((= type sb!vm:return-pc-header-type)
		       (lra-code-header object))
		      (t
		       nil))))))))

;;; SB!KERNEL:*SAVED-STATE-CHAIN* -- maintained by the C code as a
;;; list of SAPs, each SAP pointing to a saved exception state.
#!+gengc
(declaim (special *saved-state-chain*))

;;; CMU CL had
;;;   (DEFUN LOOKUP-TRACE-TABLE-ENTRY (COMPONENT PC) ..)
;;; for this case, but it hasn't been maintained in SBCL.
#!+gengc
(eval-when (:compile-toplevel :load-toplevel :execute)
  (error "hopelessly stale"))

;;; CMU CL had
;;;   (DEFUN EXTRACT-INFO-FROM-STATE (STATE) ..)
;;; for this case, but it hasn't been maintained in SBCL.
#!+gengc
(eval-when (:compile-toplevel :load-toplevel :execute)
  (error "hopelessly stale"))

;;; CMU CL had
;;;   (DEFUN COMPUTE-CALLING-FRAME (OCFP RA UP-FRAME) ..)
;;; for this case, but it hasn't been maintained in SBCL.
#!+gengc
(eval-when (:compile-toplevel :load-toplevel :execute)
  (error "hopelessly stale"))

;;;; frame utilities

;;; This returns a COMPILED-DEBUG-FUNCTION for code and pc. We fetch
;;; the SB!C::DEBUG-INFO and run down its function-map to get a
;;; SB!C::COMPILED-DEBUG-FUNCTION from the pc. The result only needs
;;; to reference the component, for function constants, and the
;;; SB!C::COMPILED-DEBUG-FUNCTION.
(defun debug-function-from-pc (component pc)
  (let ((info (%code-debug-info component)))
    (cond
     ((not info)
      (debug-signal 'no-debug-info :code-component component))
     ((eq info :bogus-lra)
      (make-bogus-debug-function "function end breakpoint"))
     (t
      (let* ((function-map (get-debug-info-function-map info))
	     (len (length function-map)))
	(declare (simple-vector function-map))
	(if (= len 1)
	    (make-compiled-debug-function (svref function-map 0) component)
	    (let ((i 1)
		  (elsewhere-p
		   (>= pc (sb!c::compiled-debug-function-elsewhere-pc
			   (svref function-map 0)))))
	      (declare (type sb!int:index i))
	      (loop
		(when (or (= i len)
			  (< pc (if elsewhere-p
				    (sb!c::compiled-debug-function-elsewhere-pc
				     (svref function-map (1+ i)))
				    (svref function-map i))))
		  (return (make-compiled-debug-function
			   (svref function-map (1- i))
			   component)))
		(incf i 2)))))))))

;;; This returns a code-location for the COMPILED-DEBUG-FUNCTION,
;;; DEBUG-FUN, and the pc into its code vector. If we stopped at a
;;; breakpoint, find the CODE-LOCATION for that breakpoint. Otherwise,
;;; make an :UNSURE code location, so it can be filled in when we
;;; figure out what is going on.
(defun code-location-from-pc (debug-fun pc escaped)
  (or (and (compiled-debug-function-p debug-fun)
	   escaped
	   (let ((data (breakpoint-data
			(compiled-debug-function-component debug-fun)
			pc nil)))
	     (when (and data (breakpoint-data-breakpoints data))
	       (let ((what (breakpoint-what
			    (first (breakpoint-data-breakpoints data)))))
		 (when (compiled-code-location-p what)
		   what)))))
      (make-compiled-code-location pc debug-fun)))

(defun frame-catches (frame)
  #!+sb-doc
  "Returns an a-list mapping catch tags to code-locations. These are
   code-locations at which execution would continue with frame as the top
   frame if someone threw to the corresponding tag."
  (let ((catch
	 #!-gengc (descriptor-sap sb!impl::*current-catch-block*)
	 #!+gengc (mutator-current-catch-block))
	(res nil)
	(fp (frame-pointer (frame-real-frame frame))))
    (loop
      (when (zerop (sap-int catch)) (return (nreverse res)))
      (when (sap= fp
		  #!-alpha
		  (sap-ref-sap catch
				      (* sb!vm:catch-block-current-cont-slot
					 sb!vm:word-bytes))
		  #!+alpha
		  (:int-sap
		   (sap-ref-32 catch
				      (* sb!vm:catch-block-current-cont-slot
					 sb!vm:word-bytes))))
	(let* (#!-(or gengc x86)
	       (lra (stack-ref catch sb!vm:catch-block-entry-pc-slot))
	       #!+(or gengc x86)
	       (ra (sap-ref-sap
		    catch (* sb!vm:catch-block-entry-pc-slot
			     sb!vm:word-bytes)))
	       #!-x86
	       (component
		(stack-ref catch sb!vm:catch-block-current-code-slot))
	       #!+x86
	       (component (component-from-component-ptr
			   (component-ptr-from-pc ra)))
	       (offset
		#!-(or gengc x86)
		(* (- (1+ (get-header-data lra))
		      (get-header-data component))
		   sb!vm:word-bytes)
		#!+gengc
		(+ (- (sap-int ra)
		      (get-lisp-obj-address component)
		      (get-header-data component))
		   sb!vm:other-pointer-type)
		#!+x86
		(- (sap-int ra)
		   (- (get-lisp-obj-address component)
		      sb!vm:other-pointer-type)
		   (* (get-header-data component) sb!vm:word-bytes))))
	  (push (cons #!-x86
		      (stack-ref catch sb!vm:catch-block-tag-slot)
		      #!+x86
		      (make-lisp-obj
		       (sap-ref-32 catch (* sb!vm:catch-block-tag-slot
						   sb!vm:word-bytes)))
		      (make-compiled-code-location
		       offset (frame-debug-function frame)))
		res)))
      (setf catch
	    #!-alpha
	    (sap-ref-sap catch
				(* sb!vm:catch-block-previous-catch-slot
				   sb!vm:word-bytes))
	    #!+alpha
	    (:int-sap
	     (sap-ref-32 catch
				(* sb!vm:catch-block-previous-catch-slot
				   sb!vm:word-bytes)))))))

;;; If an interpreted frame, return the real frame, otherwise frame.
(defun frame-real-frame (frame)
  (etypecase frame
    (compiled-frame frame)
    (interpreted-frame (interpreted-frame-real-frame frame))))

;;;; operations on DEBUG-FUNCTIONs

(defmacro do-debug-function-blocks ((block-var debug-function &optional result)
				    &body body)
  #!+sb-doc
  "Executes the forms in a context with block-var bound to each debug-block in
   debug-function successively. Result is an optional form to execute for
   return values, and DO-DEBUG-FUNCTION-BLOCKS returns nil if there is no
   result form. This signals a no-debug-blocks condition when the
   debug-function lacks debug-block information."
  (let ((blocks (gensym))
	(i (gensym)))
    `(let ((,blocks (debug-function-debug-blocks ,debug-function)))
       (declare (simple-vector ,blocks))
       (dotimes (,i (length ,blocks) ,result)
	 (let ((,block-var (svref ,blocks ,i)))
	   ,@body)))))

(defmacro do-debug-function-variables ((var debug-function &optional result)
				       &body body)
  #!+sb-doc
  "Executes body in a context with var bound to each debug-var in
   debug-function. This returns the value of executing result (defaults to
   nil). This may iterate over only some of debug-function's variables or none
   depending on debug policy; for example, possibly the compilation only
   preserved argument information."
  (let ((vars (gensym))
	(i (gensym)))
    `(let ((,vars (debug-function-debug-vars ,debug-function)))
       (declare (type (or null simple-vector) ,vars))
       (if ,vars
	   (dotimes (,i (length ,vars) ,result)
	     (let ((,var (svref ,vars ,i)))
	       ,@body))
	   ,result))))

(defun debug-function-function (debug-function)
  #!+sb-doc
  "Returns the Common Lisp function associated with the debug-function. This
   returns nil if the function is unavailable or is non-existent as a user
   callable function object."
  (let ((cached-value (debug-function-%function debug-function)))
    (if (eq cached-value :unparsed)
	(setf (debug-function-%function debug-function)
	      (etypecase debug-function
		(compiled-debug-function
		 (let ((component
			(compiled-debug-function-component debug-function))
		       (start-pc
			(sb!c::compiled-debug-function-start-pc
			 (compiled-debug-function-compiler-debug-fun
			  debug-function))))
		   (do ((entry (%code-entry-points component)
			       (%function-next entry)))
		       ((null entry) nil)
		     (when (= start-pc
			      (sb!c::compiled-debug-function-start-pc
			       (compiled-debug-function-compiler-debug-fun
				(function-debug-function entry))))
		       (return entry)))))
		(interpreted-debug-function
		 (sb!c::lambda-eval-info-function
		  (sb!c::leaf-info
		   (interpreted-debug-function-ir1-lambda debug-function))))
		(bogus-debug-function nil)))
	cached-value)))

(defun debug-function-name (debug-function)
  #!+sb-doc
  "Returns the name of the function represented by debug-function. This may
   be a string or a cons; do not assume it is a symbol."
  (etypecase debug-function
    (compiled-debug-function
     (sb!c::compiled-debug-function-name
      (compiled-debug-function-compiler-debug-fun debug-function)))
    (interpreted-debug-function
     (sb!c::lambda-name (interpreted-debug-function-ir1-lambda
			 debug-function)))
    (bogus-debug-function
     (bogus-debug-function-%name debug-function))))

(defun function-debug-function (fun)
  #!+sb-doc
  "Returns a debug-function that represents debug information for function."
  (case (get-type fun)
    (#.sb!vm:closure-header-type
     (function-debug-function (%closure-function fun)))
    (#.sb!vm:funcallable-instance-header-type
     (cond ((sb!eval:interpreted-function-p fun)
	    (make-interpreted-debug-function
	     (or (sb!eval::interpreted-function-definition fun)
		 (sb!eval::convert-interpreted-fun fun))))
	   (t
	    (function-debug-function (funcallable-instance-function fun)))))
    ((#.sb!vm:function-header-type #.sb!vm:closure-function-header-type)
      (let* ((name (%function-name fun))
	     (component (function-code-header fun))
	     (res (find-if
		   #'(lambda (x)
		       (and (sb!c::compiled-debug-function-p x)
			    (eq (sb!c::compiled-debug-function-name x) name)
			    (eq (sb!c::compiled-debug-function-kind x) nil)))
		   (get-debug-info-function-map
		    (%code-debug-info component)))))
	(if res
	    (make-compiled-debug-function res component)
	    ;; KLUDGE: comment from CMU CL:
	    ;;   This used to be the non-interpreted branch, but
	    ;;   William wrote it to return the debug-fun of fun's XEP
	    ;;   instead of fun's debug-fun. The above code does this
	    ;;   more correctly, but it doesn't get or eliminate all
	    ;;   appropriate cases. It mostly works, and probably
	    ;;   works for all named functions anyway.
	    ;; -- WHN 20000120
	    (debug-function-from-pc component
				    (* (- (function-word-offset fun)
					  (get-header-data component))
				       sb!vm:word-bytes)))))))

(defun debug-function-kind (debug-function)
  #!+sb-doc
  "Returns the kind of the function which is one of :OPTIONAL, :EXTERNAL,
   :TOP-level, :CLEANUP, or NIL."
  ;; FIXME: This "is one of" information should become part of the function
  ;; declamation, not just a doc string
  (etypecase debug-function
    (compiled-debug-function
     (sb!c::compiled-debug-function-kind
      (compiled-debug-function-compiler-debug-fun debug-function)))
    (interpreted-debug-function
     (sb!c::lambda-kind (interpreted-debug-function-ir1-lambda
			 debug-function)))
    (bogus-debug-function
     nil)))

(defun debug-var-info-available (debug-function)
  #!+sb-doc
  "Is there any variable information for DEBUG-FUNCTION?"
  (not (not (debug-function-debug-vars debug-function))))

(defun debug-function-symbol-variables (debug-function symbol)
  #!+sb-doc
  "Returns a list of debug-vars in debug-function having the same name
   and package as symbol. If symbol is uninterned, then this returns a list of
   debug-vars without package names and with the same name as symbol. The
   result of this function is limited to the availability of variable
   information in debug-function; for example, possibly debug-function only
   knows about its arguments."
  (let ((vars (ambiguous-debug-vars debug-function (symbol-name symbol)))
	(package (and (symbol-package symbol)
		      (package-name (symbol-package symbol)))))
    (delete-if (if (stringp package)
		   (lambda (var)
		     (let ((p (debug-var-package-name var)))
		       (or (not (stringp p))
			   (string/= p package))))
		   (lambda (var)
		     (stringp (debug-var-package-name var))))
	       vars)))

(defun ambiguous-debug-vars (debug-function name-prefix-string)
   "Returns a list of debug-vars in debug-function whose names contain
    name-prefix-string as an intial substring. The result of this function is
    limited to the availability of variable information in debug-function; for
    example, possibly debug-function only knows about its arguments."
  (declare (simple-string name-prefix-string))
  (let ((variables (debug-function-debug-vars debug-function)))
    (declare (type (or null simple-vector) variables))
    (if variables
	(let* ((len (length variables))
	       (prefix-len (length name-prefix-string))
	       (pos (find-variable name-prefix-string variables len))
	       (res nil))
	  (when pos
	    ;; Find names from pos to variable's len that contain prefix.
	    (do ((i pos (1+ i)))
		((= i len))
	      (let* ((var (svref variables i))
		     (name (debug-var-symbol-name var))
		     (name-len (length name)))
		(declare (simple-string name))
		(when (/= (or (string/= name-prefix-string name
					:end1 prefix-len :end2 name-len)
			      prefix-len)
			  prefix-len)
		  (return))
		(push var res)))
	    (setq res (nreverse res)))
	  res))))

;;; This returns a position in variables for one containing name as an
;;; initial substring. End is the length of variables if supplied.
(defun find-variable (name variables &optional end)
  (declare (simple-vector variables)
	   (simple-string name))
  (let ((name-len (length name)))
    (position name variables
	      :test #'(lambda (x y)
			(let* ((y (debug-var-symbol-name y))
			       (y-len (length y)))
			  (declare (simple-string y))
			  (and (>= y-len name-len)
			       (string= x y :end1 name-len :end2 name-len))))
	      :end (or end (length variables)))))

(defun debug-function-lambda-list (debug-function)
  #!+sb-doc
  "Returns a list representing the lambda-list for debug-function. The list
   has the following structure:
      (required-var1 required-var2
       ...
       (:optional var3 suppliedp-var4)
       (:optional var5)
       ...
       (:rest var6) (:rest var7)
       ...
       (:keyword keyword-symbol var8 suppliedp-var9)
       (:keyword keyword-symbol var10)
       ...
      )
   Each VARi is a DEBUG-VAR; however it may be the symbol :deleted it
   is unreferenced in debug-function. This signals a lambda-list-unavailable
   condition when there is no argument list information."
  (etypecase debug-function
    (compiled-debug-function
     (compiled-debug-function-lambda-list debug-function))
    (interpreted-debug-function
     (interpreted-debug-function-lambda-list debug-function))
    (bogus-debug-function
     nil)))

;;; The hard part is when the lambda-list is unparsed. If it is
;;; unparsed, and all the arguments are required, this is still pretty
;;; easy; just whip the appropriate DEBUG-VARs into a list. Otherwise,
;;; we have to pick out the funny arguments including any suppliedp
;;; variables. In this situation, the ir1-lambda is an external entry
;;; point that takes arguments users really pass in. It looks at those
;;; and computes defaults and suppliedp variables, ultimately passing
;;; everything defined as a a parameter to the real function as final
;;; arguments. If this has to compute the lambda list, it caches it in
;;; debug-function.
(defun interpreted-debug-function-lambda-list (debug-function)
  (let ((lambda-list (debug-function-%lambda-list debug-function))
	(debug-vars (debug-function-debug-vars debug-function))
	(ir1-lambda (interpreted-debug-function-ir1-lambda debug-function))
	(res nil))
    (if (eq lambda-list :unparsed)
	(flet ((frob (v debug-vars)
		 (if (sb!c::lambda-var-refs v)
		     (find v debug-vars
			   :key #'interpreted-debug-var-ir1-var)
		     :deleted)))
	  (let ((xep-args (sb!c::lambda-optional-dispatch ir1-lambda)))
	    (if (and xep-args
		     (eq (sb!c::optional-dispatch-main-entry xep-args)
			 ir1-lambda))
		;; There are rest, optional, keyword, and suppliedp vars.
		(let ((final-args (sb!c::lambda-vars ir1-lambda)))
		  (dolist (xep-arg (sb!c::optional-dispatch-arglist xep-args))
		    (let ((info (sb!c::lambda-var-arg-info xep-arg))
			  (final-arg (pop final-args)))
		      (cond (info
			     (case (sb!c::arg-info-kind info)
			       (:required
				(push (frob final-arg debug-vars) res))
			       (:keyword
				(push (list :keyword
					    (sb!c::arg-info-key info)
					    (frob final-arg debug-vars))
				      res))
			       (:rest
				(push (list :rest (frob final-arg debug-vars))
				      res))
			       (:optional
				(push (list :optional
					    (frob final-arg debug-vars))
				      res)))
			     (when (sb!c::arg-info-supplied-p info)
			       (nconc
				(car res)
				(list (frob (pop final-args) debug-vars)))))
			    (t
			     (push (frob final-arg debug-vars) res)))))
		  (setf (debug-function-%lambda-list debug-function)
			(nreverse res)))
		;; All required args, so return them in a list.
		(dolist (v (sb!c::lambda-vars ir1-lambda)
			   (setf (debug-function-%lambda-list debug-function)
				 (nreverse res)))
		  (push (frob v debug-vars) res)))))
	;; Everything's unparsed and cached, so return it.
	lambda-list)))

;;; If this has to compute the lambda list, it caches it in debug-function.
(defun compiled-debug-function-lambda-list (debug-function)
  (let ((lambda-list (debug-function-%lambda-list debug-function)))
    (cond ((eq lambda-list :unparsed)
	   (multiple-value-bind (args argsp)
	       (parse-compiled-debug-function-lambda-list debug-function)
	     (setf (debug-function-%lambda-list debug-function) args)
	     (if argsp
		 args
		 (debug-signal 'lambda-list-unavailable
			       :debug-function debug-function))))
	  (lambda-list)
	  ((bogus-debug-function-p debug-function)
	   nil)
	  ((sb!c::compiled-debug-function-arguments
	    (compiled-debug-function-compiler-debug-fun
	     debug-function))
	   ;; If the packed information is there (whether empty or not) as
	   ;; opposed to being nil, then returned our cached value (nil).
	   nil)
	  (t
	   ;; Our cached value is nil, and the packed lambda-list information
	   ;; is nil, so we don't have anything available.
	   (debug-signal 'lambda-list-unavailable
			 :debug-function debug-function)))))

;;; COMPILED-DEBUG-FUNCTION-LAMBDA-LIST calls this when a
;;; compiled-debug-function has no lambda-list information cached. It
;;; returns the lambda-list as the first value and whether there was
;;; any argument information as the second value. Therefore, nil and t
;;; means there were no arguments, but nil and nil means there was no
;;; argument information.
(defun parse-compiled-debug-function-lambda-list (debug-function)
  (let ((args (sb!c::compiled-debug-function-arguments
	       (compiled-debug-function-compiler-debug-fun
		debug-function))))
    (cond
     ((not args)
      (values nil nil))
     ((eq args :minimal)
      (values (coerce (debug-function-debug-vars debug-function) 'list)
	      t))
     (t
      (let ((vars (debug-function-debug-vars debug-function))
	    (i 0)
	    (len (length args))
	    (res nil)
	    (optionalp nil))
	(declare (type (or null simple-vector) vars))
	(loop
	  (when (>= i len) (return))
	  (let ((ele (aref args i)))
	    (cond
	     ((symbolp ele)
	      (case ele
		(sb!c::deleted
		 ;; Deleted required arg at beginning of args array.
		 (push :deleted res))
		(sb!c::optional-args
		 (setf optionalp t))
		(sb!c::supplied-p
		 ;; SUPPLIED-P var immediately following keyword or
		 ;; optional. Stick the extra var in the result
		 ;; element representing the keyword or optional,
		 ;; which is the previous one.
		 (nconc (car res)
			(list (compiled-debug-function-lambda-list-var
			       args (incf i) vars))))
		(sb!c::rest-arg
		 (push (list :rest
			     (compiled-debug-function-lambda-list-var
			      args (incf i) vars))
		       res))
		(sb!c::more-arg
		 ;; Just ignore the fact that the next two args are
		 ;; the &MORE arg context and count, and act like they
		 ;; are regular arguments.
		 nil)
		(t
		 ;; &KEY arg
		 (push (list :keyword
			     ele
			     (compiled-debug-function-lambda-list-var
			      args (incf i) vars))
		       res))))
	     (optionalp
	      ;; We saw an optional marker, so the following
	      ;; non-symbols are indexes indicating optional
	      ;; variables.
	      (push (list :optional (svref vars ele)) res))
	     (t
	      ;; Required arg at beginning of args array.
	      (push (svref vars ele) res))))
	  (incf i))
	(values (nreverse res) t))))))

;;; This is used in COMPILED-DEBUG-FUNCTION-LAMBDA-LIST.
(defun compiled-debug-function-lambda-list-var (args i vars)
  (declare (type (simple-array * (*)) args)
	   (simple-vector vars))
  (let ((ele (aref args i)))
    (cond ((not (symbolp ele)) (svref vars ele))
	  ((eq ele 'sb!c::deleted) :deleted)
	  (t (error "malformed arguments description")))))

(defun compiled-debug-function-debug-info (debug-fun)
  (%code-debug-info (compiled-debug-function-component debug-fun)))

;;;; unpacking variable and basic block data

(defvar *parsing-buffer*
  (make-array 20 :adjustable t :fill-pointer t))
(defvar *other-parsing-buffer*
  (make-array 20 :adjustable t :fill-pointer t))
;;; PARSE-DEBUG-BLOCKS, PARSE-DEBUG-VARS and UNCOMPACT-FUNCTION-MAP
;;; use this to unpack binary encoded information. It returns the
;;; values returned by the last form in body.
;;;
;;; This binds buffer-var to *parsing-buffer*, makes sure it starts at
;;; element zero, and makes sure if we unwind, we nil out any set
;;; elements for GC purposes.
;;;
;;; This also binds other-var to *other-parsing-buffer* when it is
;;; supplied, making sure it starts at element zero and that we nil
;;; out any elements if we unwind.
;;;
;;; This defines the local macro RESULT that takes a buffer, copies
;;; its elements to a resulting simple-vector, nil's out elements, and
;;; restarts the buffer at element zero. RESULT returns the
;;; simple-vector.
(eval-when (:compile-toplevel :execute)
(sb!xc:defmacro with-parsing-buffer ((buffer-var &optional other-var)
				     &body body)
  (let ((len (gensym))
	(res (gensym)))
    `(unwind-protect
	 (let ((,buffer-var *parsing-buffer*)
	       ,@(if other-var `((,other-var *other-parsing-buffer*))))
	   (setf (fill-pointer ,buffer-var) 0)
	   ,@(if other-var `((setf (fill-pointer ,other-var) 0)))
	   (macrolet ((result (buf)
			`(let* ((,',len (length ,buf))
				(,',res (make-array ,',len)))
			   (replace ,',res ,buf :end1 ,',len :end2 ,',len)
			   (fill ,buf nil :end ,',len)
			   (setf (fill-pointer ,buf) 0)
			   ,',res)))
	     ,@body))
     (fill *parsing-buffer* nil)
     ,@(if other-var `((fill *other-parsing-buffer* nil))))))
) ; EVAL-WHEN

;;; The argument is a debug internals structure. This returns the
;;; debug-blocks for debug-function, regardless of whether we have
;;; unpacked them yet. It signals a no-debug-blocks condition if it
;;; can't return the blocks.
(defun debug-function-debug-blocks (debug-function)
  (let ((blocks (debug-function-blocks debug-function)))
    (cond ((eq blocks :unparsed)
	   (setf (debug-function-blocks debug-function)
		 (parse-debug-blocks debug-function))
	   (unless (debug-function-blocks debug-function)
	     (debug-signal 'no-debug-blocks
			   :debug-function debug-function))
	   (debug-function-blocks debug-function))
	  (blocks)
	  (t
	   (debug-signal 'no-debug-blocks
			 :debug-function debug-function)))))

;;; This returns a simple-vector of debug-blocks or nil. NIL indicates
;;; there was no basic block information.
(defun parse-debug-blocks (debug-function)
  (etypecase debug-function
    (compiled-debug-function
     (parse-compiled-debug-blocks debug-function))
    (bogus-debug-function
     (debug-signal 'no-debug-blocks :debug-function debug-function))
    (interpreted-debug-function
     (parse-interpreted-debug-blocks debug-function))))

;;; This does some of the work of PARSE-DEBUG-BLOCKS.
(defun parse-compiled-debug-blocks (debug-function)
  (let* ((debug-fun (compiled-debug-function-compiler-debug-fun
		     debug-function))
	 (var-count (length (debug-function-debug-vars debug-function)))
	 (blocks (sb!c::compiled-debug-function-blocks debug-fun))
	 ;; KLUDGE: 8 is a hard-wired constant in the compiler for the
	 ;; element size of the packed binary representation of the
	 ;; blocks data.
	 (live-set-len (ceiling var-count 8))
	 (tlf-number (sb!c::compiled-debug-function-tlf-number debug-fun)))
    (unless blocks (return-from parse-compiled-debug-blocks nil))
    (macrolet ((aref+ (a i) `(prog1 (aref ,a ,i) (incf ,i))))
      (with-parsing-buffer (blocks-buffer locations-buffer)
	(let ((i 0)
	      (len (length blocks))
	      (last-pc 0))
	  (loop
	    (when (>= i len) (return))
	    (let ((succ-and-flags (aref+ blocks i))
		  (successors nil))
	      (declare (type (unsigned-byte 8) succ-and-flags)
		       (list successors))
	      (dotimes (k (ldb sb!c::compiled-debug-block-nsucc-byte
			       succ-and-flags))
		(push (sb!c::read-var-integer blocks i) successors))
	      (let* ((locations
		      (dotimes (k (sb!c::read-var-integer blocks i)
				  (result locations-buffer))
			(let ((kind (svref sb!c::*compiled-code-location-kinds*
					   (aref+ blocks i)))
			      (pc (+ last-pc
				     (sb!c::read-var-integer blocks i)))
			      (tlf-offset (or tlf-number
					      (sb!c::read-var-integer blocks
								      i)))
			      (form-number (sb!c::read-var-integer blocks i))
			      (live-set (sb!c::read-packed-bit-vector
					 live-set-len blocks i)))
			  (vector-push-extend (make-known-code-location
					       pc debug-function tlf-offset
					       form-number live-set kind)
					      locations-buffer)
			  (setf last-pc pc))))
		     (block (make-compiled-debug-block
			     locations successors
			     (not (zerop (logand
					  sb!c::compiled-debug-block-elsewhere-p
					  succ-and-flags))))))
		(vector-push-extend block blocks-buffer)
		(dotimes (k (length locations))
		  (setf (code-location-%debug-block (svref locations k))
			block))))))
	(let ((res (result blocks-buffer)))
	  (declare (simple-vector res))
	  (dotimes (i (length res))
	    (let* ((block (svref res i))
		   (succs nil))
	      (dolist (ele (debug-block-successors block))
		(push (svref res ele) succs))
	      (setf (debug-block-successors block) succs)))
	  res)))))

;;; This does some of the work of PARSE-DEBUG-BLOCKS.
(defun parse-interpreted-debug-blocks (debug-function)
  (let ((ir1-lambda (interpreted-debug-function-ir1-lambda debug-function)))
    (with-parsing-buffer (buffer)
      (sb!c::do-blocks (block (sb!c::block-component
			       (sb!c::node-block (sb!c::lambda-bind
						  ir1-lambda))))
	(when (eq ir1-lambda (sb!c::block-home-lambda block))
	  (vector-push-extend (make-interpreted-debug-block block) buffer)))
      (result buffer))))

;;; The argument is a debug internals structure. This returns nil if
;;; there is no variable information. It returns an empty
;;; simple-vector if there were no locals in the function. Otherwise
;;; it returns a simple-vector of DEBUG-VARs.
(defun debug-function-debug-vars (debug-function)
  (let ((vars (debug-function-%debug-vars debug-function)))
    (if (eq vars :unparsed)
	(setf (debug-function-%debug-vars debug-function)
	      (etypecase debug-function
		(compiled-debug-function
		 (parse-compiled-debug-vars debug-function))
		(bogus-debug-function nil)
		(interpreted-debug-function
		 (parse-interpreted-debug-vars debug-function))))
	vars)))

;;; This grabs all the variables from DEBUG-FUN's ir1-lambda, from the
;;; IR1 lambda vars, and all of its LET's. Each LET is an IR1 lambda.
;;; For each variable, we make an INTERPRETED-DEBUG-VAR. We then SORT
;;; all the variables by name. Then we go through, and for any
;;; duplicated names we distinguish the INTERPRETED-DEBUG-VARs by
;;; setting their id slots to a distinct number.
(defun parse-interpreted-debug-vars (debug-fun)
  (let* ((ir1-lambda (interpreted-debug-function-ir1-lambda debug-fun))
	 (vars (flet ((frob (ir1-lambda buf)
			(dolist (v (sb!c::lambda-vars ir1-lambda))
			  (vector-push-extend
			   (let* ((id (sb!c::leaf-name v)))
			     (make-interpreted-debug-var id v))
			   buf))))
		 (with-parsing-buffer (buf)
		   (frob ir1-lambda buf)
		   (dolist (let-lambda (sb!c::lambda-lets ir1-lambda))
		     (frob let-lambda buf))
		   (result buf)))))
    (declare (simple-vector vars))
    (sort vars #'string< :key #'debug-var-symbol-name)
    (let ((len (length vars)))
      (when (> len 1)
	(let ((i 0)
	      (j 1))
	  (block PUNT
	    (loop
	      (let* ((var-i (svref vars i))
		     (var-j (svref vars j))
		     (name (debug-var-symbol-name var-i)))
		(when (string= name (debug-var-symbol-name var-j))
		  (let ((count 1))
		    (loop
		      (setf (debug-var-id var-j) count)
		      (when (= (incf j) len) (return-from PUNT))
		      (setf var-j (svref vars j))
		      (when (string/= name (debug-var-symbol-name var-j))
			(return))
		      (incf count))))
		(setf i j)
		(incf j)
		(when (= j len) (return))))))))
    vars))

;;; Vars is the parsed variables for a minimal debug function. We need to
;;; assign names of the form ARG-NNN. We must pad with leading zeros, since
;;; the arguments must be in alphabetical order.
(defun assign-minimal-var-names (vars)
  (declare (simple-vector vars))
  (let* ((len (length vars))
	 (width (length (format nil "~D" (1- len)))))
    (dotimes (i len)
      (setf (compiled-debug-var-symbol (svref vars i))
	    (intern (format nil "ARG-~V,'0D" width i)
		    ;; KLUDGE: It's somewhat nasty to have a bare
		    ;; package name string here. It would probably be
		    ;; better to have #.(FIND-PACKAGE "SB!DEBUG")
		    ;; instead, since then at least it would transform
		    ;; correctly under package renaming and stuff.
		    ;; However, genesis can't handle dumped packages..
		    ;; -- WHN 20000129
		    ;;
		    ;; FIXME: Maybe this could be fixed by moving the
		    ;; whole debug-int.lisp file to warm init? (after
		    ;; which dumping a #.(FIND-PACKAGE ..) expression
		    ;; would work fine) If this is possible, it would
		    ;; probably be a good thing, since minimizing the
		    ;; amount of stuff in cold init is basically good.
		    "SB-DEBUG")))))

;;; Parse the packed representation of DEBUG-VARs from
;;; DEBUG-FUNCTION's SB!C::COMPILED-DEBUG-FUNCTION, returning a vector
;;; of DEBUG-VARs, or NIL if there was no information to parse.
(defun parse-compiled-debug-vars (debug-function)
  (let* ((cdebug-fun (compiled-debug-function-compiler-debug-fun debug-function))
	 (packed-vars (sb!c::compiled-debug-function-variables cdebug-fun))
	 (args-minimal (eq (sb!c::compiled-debug-function-arguments cdebug-fun)
			   :minimal)))
    (when packed-vars
      (do ((i 0)
	   (buffer (make-array 0 :fill-pointer 0 :adjustable t)))
	  ((>= i (length packed-vars))
	   (let ((result (coerce buffer 'simple-vector)))
	     (when args-minimal
	       (assign-minimal-var-names result))
	     result))
	(flet ((geti () (prog1 (aref packed-vars i) (incf i))))
	  (let* ((flags (geti))
		 (minimal (logtest sb!c::compiled-debug-var-minimal-p flags))
		 (deleted (logtest sb!c::compiled-debug-var-deleted-p flags))
		 (live (logtest sb!c::compiled-debug-var-environment-live flags))
		 (save (logtest sb!c::compiled-debug-var-save-loc-p flags))
		 (symbol (if minimal nil (geti)))
		 (id (if (logtest sb!c::compiled-debug-var-id-p flags)
			 (geti)
			 0))
		 (sc-offset (if deleted 0 (geti)))
		 (save-sc-offset (if save (geti) nil)))
	    (aver (not (and args-minimal (not minimal))))
	    (vector-push-extend (make-compiled-debug-var symbol
							 id
							 live
							 sc-offset
							 save-sc-offset)
				buffer)))))))

;;;; unpacking minimal debug functions

(eval-when (:compile-toplevel :execute)

;;; sleazoid "macro" to keep our indentation sane in UNCOMPACT-FUNCTION-MAP
(sb!xc:defmacro make-uncompacted-debug-fun ()
  '(sb!c::make-compiled-debug-function
    :name
    (let ((base (ecase (ldb sb!c::minimal-debug-function-name-style-byte
			    options)
		  (#.sb!c::minimal-debug-function-name-symbol
		   (intern (sb!c::read-var-string map i)
			   (sb!c::compiled-debug-info-package info)))
		  (#.sb!c::minimal-debug-function-name-packaged
		   (let ((pkg (sb!c::read-var-string map i)))
		     (intern (sb!c::read-var-string map i) pkg)))
		  (#.sb!c::minimal-debug-function-name-uninterned
		   (make-symbol (sb!c::read-var-string map i)))
		  (#.sb!c::minimal-debug-function-name-component
		   (sb!c::compiled-debug-info-name info)))))
      (if (logtest flags sb!c::minimal-debug-function-setf-bit)
	  `(setf ,base)
	  base))
    :kind (svref sb!c::*minimal-debug-function-kinds*
		 (ldb sb!c::minimal-debug-function-kind-byte options))
    :variables
    (when vars-p
      (let ((len (sb!c::read-var-integer map i)))
	(prog1 (subseq map i (+ i len))
	  (incf i len))))
    :arguments (when vars-p :minimal)
    :returns
    (ecase (ldb sb!c::minimal-debug-function-returns-byte options)
      (#.sb!c::minimal-debug-function-returns-standard
       :standard)
      (#.sb!c::minimal-debug-function-returns-fixed
       :fixed)
      (#.sb!c::minimal-debug-function-returns-specified
       (with-parsing-buffer (buf)
	 (dotimes (idx (sb!c::read-var-integer map i))
	   (vector-push-extend (sb!c::read-var-integer map i) buf))
	 (result buf))))
    :return-pc (sb!c::read-var-integer map i)
    :old-fp (sb!c::read-var-integer map i)
    :nfp (when (logtest flags sb!c::minimal-debug-function-nfp-bit)
	   (sb!c::read-var-integer map i))
    :start-pc
    (progn
      (setq code-start-pc (+ code-start-pc (sb!c::read-var-integer map i)))
      (+ code-start-pc (sb!c::read-var-integer map i)))
    :elsewhere-pc
    (setq elsewhere-pc (+ elsewhere-pc (sb!c::read-var-integer map i)))))

) ; EVAL-WHEN

;;; Return a normal function map derived from a minimal debug info
;;; function map. This involves looping parsing
;;; minimal-debug-functions and then building a vector out of them.
;;;
;;; FIXME: This and its helper macro just above become dead code now
;;; that we no longer use compacted function maps.
(defun uncompact-function-map (info)
  (declare (type sb!c::compiled-debug-info info))

  ;; (This is stubified until we solve the problem of representing
  ;; debug information in a way which plays nicely with package renaming.)
  (error "FIXME: dead code UNCOMPACT-FUNCTION-MAP (was stub)")

  (let* ((map (sb!c::compiled-debug-info-function-map info))
	 (i 0)
	 (len (length map))
	 (code-start-pc 0)
	 (elsewhere-pc 0))
    (declare (type (simple-array (unsigned-byte 8) (*)) map))
    (sb!int:collect ((res))
      (loop
	(when (= i len) (return))
	(let* ((options (prog1 (aref map i) (incf i)))
	       (flags (prog1 (aref map i) (incf i)))
	       (vars-p (logtest flags
				sb!c::minimal-debug-function-variables-bit))
	       (dfun (make-uncompacted-debug-fun)))
	  (res code-start-pc)
	  (res dfun)))

      (coerce (cdr (res)) 'simple-vector))))

;;; a map from minimal DEBUG-INFO function maps to unpacked
;;; versions thereof
(defvar *uncompacted-function-maps* (make-hash-table :test 'eq))

;;; Return a FUNCTION-MAP for a given COMPILED-DEBUG-info object. If
;;; the info is minimal, and has not been parsed, then parse it.
;;;
;;; FIXME: Now that we no longer use the MINIMAL-DEBUG-FUNCTION
;;; representation, calls to this function can be replaced by calls to
;;; the bare COMPILED-DEBUG-INFO-FUNCTION-MAP slot accessor function,
;;; and this function and everything it calls become dead code which
;;; can be deleted.
(defun get-debug-info-function-map (info)
  (declare (type sb!c::compiled-debug-info info))
  (let ((map (sb!c::compiled-debug-info-function-map info)))
    (if (simple-vector-p map)
	map
	(or (gethash map *uncompacted-function-maps*)
	    (setf (gethash map *uncompacted-function-maps*)
		  (uncompact-function-map info))))))

;;;; CODE-LOCATIONs

;;; If we're sure of whether code-location is known, return T or NIL.
;;; If we're :UNSURE, then try to fill in the code-location's slots.
;;; This determines whether there is any debug-block information, and
;;; if code-location is known.
;;;
;;; ??? IF this conses closures every time it's called, then break off the
;;; :UNSURE part to get the HANDLER-CASE into another function.
(defun code-location-unknown-p (basic-code-location)
  (ecase (code-location-%unknown-p basic-code-location)
    ((t) t)
    ((nil) nil)
    (:unsure
     (setf (code-location-%unknown-p basic-code-location)
	   (handler-case (not (fill-in-code-location basic-code-location))
	     (no-debug-blocks () t))))))

;;; Return the DEBUG-BLOCK containing code-location if it is available.
;;; Some debug policies inhibit debug-block information, and if none
;;; is available, then this signals a NO-DEBUG-BLOCKS condition.
(defun code-location-debug-block (basic-code-location)
  (let ((block (code-location-%debug-block basic-code-location)))
    (if (eq block :unparsed)
	(etypecase basic-code-location
	  (compiled-code-location
	   (compute-compiled-code-location-debug-block basic-code-location))
	  (interpreted-code-location
	   (setf (code-location-%debug-block basic-code-location)
		 (make-interpreted-debug-block
		  (sb!c::node-block
		   (interpreted-code-location-ir1-node basic-code-location))))))
	block)))

;;; Store and return BASIC-CODE-LOCATION's debug-block. We determines
;;; the correct one using the code-location's pc. We use
;;; DEBUG-FUNCTION-DEBUG-BLOCKS to return the cached block information
;;; or signal a NO-DEBUG-BLOCKS condition. The blocks are sorted by
;;; their first code-location's pc, in ascending order. Therefore, as
;;; soon as we find a block that starts with a pc greater than
;;; basic-code-location's pc, we know the previous block contains the
;;; pc. If we get to the last block, then the code-location is either
;;; in the second to last block or the last block, and we have to be
;;; careful in determining this since the last block could be code at
;;; the end of the function. We have to check for the last block being
;;; code first in order to see how to compare the code-location's pc.
(defun compute-compiled-code-location-debug-block (basic-code-location)
  (let* ((pc (compiled-code-location-pc basic-code-location))
	 (debug-function (code-location-debug-function
			  basic-code-location))
	 (blocks (debug-function-debug-blocks debug-function))
	 (len (length blocks)))
    (declare (simple-vector blocks))
    (setf (code-location-%debug-block basic-code-location)
	  (if (= len 1)
	      (svref blocks 0)
	      (do ((i 1 (1+ i))
		   (end (1- len)))
		  ((= i end)
		   (let ((last (svref blocks end)))
		     (cond
		      ((debug-block-elsewhere-p last)
		       (if (< pc
			      (sb!c::compiled-debug-function-elsewhere-pc
			       (compiled-debug-function-compiler-debug-fun
				debug-function)))
			   (svref blocks (1- end))
			   last))
		      ((< pc
			  (compiled-code-location-pc
			   (svref (compiled-debug-block-code-locations last)
				  0)))
		       (svref blocks (1- end)))
		      (t last))))
		(declare (type sb!c::index i end))
		(when (< pc
			 (compiled-code-location-pc
			  (svref (compiled-debug-block-code-locations
				  (svref blocks i))
				 0)))
		  (return (svref blocks (1- i)))))))))

(defun code-location-debug-source (code-location)
  #!+sb-doc
  "Returns the code-location's debug-source."
  (etypecase code-location
    (compiled-code-location
     (let* ((info (compiled-debug-function-debug-info
		   (code-location-debug-function code-location)))
	    (sources (sb!c::compiled-debug-info-source info))
	    (len (length sources)))
       (declare (list sources))
       (when (zerop len)
	 (debug-signal 'no-debug-blocks :debug-function
		       (code-location-debug-function code-location)))
       (if (= len 1)
	   (car sources)
	   (do ((prev sources src)
		(src (cdr sources) (cdr src))
		(offset (code-location-top-level-form-offset code-location)))
	       ((null src) (car prev))
	     (when (< offset (sb!c::debug-source-source-root (car src)))
	       (return (car prev)))))))
    (interpreted-code-location
     (first
      (let ((sb!c::*lexenv* (make-null-lexenv)))
	(sb!c::debug-source-for-info
	 (sb!c::component-source-info
	  (sb!c::block-component
	   (sb!c::node-block
	    (interpreted-code-location-ir1-node code-location))))))))))

(defun code-location-top-level-form-offset (code-location)
  #!+sb-doc
  "Returns the number of top-level forms before the one containing
   code-location as seen by the compiler in some compilation unit. A
   compilation unit is not necessarily a single file, see the section on
   debug-sources."
  (when (code-location-unknown-p code-location)
    (error 'unknown-code-location :code-location code-location))
  (let ((tlf-offset (code-location-%tlf-offset code-location)))
    (cond ((eq tlf-offset :unparsed)
	   (etypecase code-location
	     (compiled-code-location
	      (unless (fill-in-code-location code-location)
		;; This check should be unnecessary. We're missing
		;; debug info the compiler should have dumped.
		(error "internal error: unknown code location"))
	      (code-location-%tlf-offset code-location))
	     (interpreted-code-location
	      (setf (code-location-%tlf-offset code-location)
		    (sb!c::source-path-tlf-number
		     (sb!c::node-source-path
		      (interpreted-code-location-ir1-node code-location)))))))
	  (t tlf-offset))))

(defun code-location-form-number (code-location)
  #!+sb-doc
  "Returns the number of the form corresponding to code-location. The form
   number is derived by a walking the subforms of a top-level form in
   depth-first order."
  (when (code-location-unknown-p code-location)
    (error 'unknown-code-location :code-location code-location))
  (let ((form-num (code-location-%form-number code-location)))
    (cond ((eq form-num :unparsed)
	   (etypecase code-location
	     (compiled-code-location
	      (unless (fill-in-code-location code-location)
		;; This check should be unnecessary. We're missing
		;; debug info the compiler should have dumped.
		(error "internal error: unknown code location"))
	      (code-location-%form-number code-location))
	     (interpreted-code-location
	      (setf (code-location-%form-number code-location)
		    (sb!c::source-path-form-number
		     (sb!c::node-source-path
		      (interpreted-code-location-ir1-node code-location)))))))
	  (t form-num))))

(defun code-location-kind (code-location)
  #!+sb-doc
  "Return the kind of CODE-LOCATION, one of:
     :interpreted, :unknown-return, :known-return, :internal-error,
     :non-local-exit, :block-start, :call-site, :single-value-return,
     :non-local-entry"
  (when (code-location-unknown-p code-location)
    (error 'unknown-code-location :code-location code-location))
  (etypecase code-location
    (compiled-code-location
     (let ((kind (compiled-code-location-kind code-location)))
       (cond ((not (eq kind :unparsed)) kind)
	     ((not (fill-in-code-location code-location))
	      ;; This check should be unnecessary. We're missing
	      ;; debug info the compiler should have dumped.
	      (error "internal error: unknown code location"))
	     (t
	      (compiled-code-location-kind code-location)))))
    (interpreted-code-location
     :interpreted)))

;;; This returns CODE-LOCATION's live-set if it is available. If
;;; there is no debug-block information, this returns NIL.
(defun compiled-code-location-live-set (code-location)
  (if (code-location-unknown-p code-location)
      nil
      (let ((live-set (compiled-code-location-%live-set code-location)))
	(cond ((eq live-set :unparsed)
	       (unless (fill-in-code-location code-location)
		 ;; This check should be unnecessary. We're missing
		 ;; debug info the compiler should have dumped.
		 ;;
		 ;; FIXME: This error and comment happen over and over again.
		 ;; Make them a shared function.
		 (error "internal error: unknown code location"))
	       (compiled-code-location-%live-set code-location))
	      (t live-set)))))

;;; true if OBJ1 and OBJ2 are the same place in the code
(defun code-location= (obj1 obj2)
  (etypecase obj1
    (compiled-code-location
     (etypecase obj2
       (compiled-code-location
	(and (eq (code-location-debug-function obj1)
		 (code-location-debug-function obj2))
	     (sub-compiled-code-location= obj1 obj2)))
       (interpreted-code-location
	nil)))
    (interpreted-code-location
     (etypecase obj2
       (compiled-code-location
	nil)
       (interpreted-code-location
	(eq (interpreted-code-location-ir1-node obj1)
	    (interpreted-code-location-ir1-node obj2)))))))
(defun sub-compiled-code-location= (obj1 obj2)
  (= (compiled-code-location-pc obj1)
     (compiled-code-location-pc obj2)))

;;; Fill in CODE-LOCATION's :UNPARSED slots, returning T or NIL
;;; depending on whether the code-location was known in its
;;; debug-function's debug-block information. This may signal a
;;; NO-DEBUG-BLOCKS condition due to DEBUG-FUNCTION-DEBUG-BLOCKS, and
;;; it assumes the %UNKNOWN-P slot is already set or going to be set.
(defun fill-in-code-location (code-location)
  (declare (type compiled-code-location code-location))
  (let* ((debug-function (code-location-debug-function code-location))
	 (blocks (debug-function-debug-blocks debug-function)))
    (declare (simple-vector blocks))
    (dotimes (i (length blocks) nil)
      (let* ((block (svref blocks i))
	     (locations (compiled-debug-block-code-locations block)))
	(declare (simple-vector locations))
	(dotimes (j (length locations))
	  (let ((loc (svref locations j)))
	    (when (sub-compiled-code-location= code-location loc)
	      (setf (code-location-%debug-block code-location) block)
	      (setf (code-location-%tlf-offset code-location)
		    (code-location-%tlf-offset loc))
	      (setf (code-location-%form-number code-location)
		    (code-location-%form-number loc))
	      (setf (compiled-code-location-%live-set code-location)
		    (compiled-code-location-%live-set loc))
	      (setf (compiled-code-location-kind code-location)
		    (compiled-code-location-kind loc))
	      (return-from fill-in-code-location t))))))))

;;;; operations on DEBUG-BLOCKs

(defmacro do-debug-block-locations ((code-var debug-block &optional return)
				    &body body)
  #!+sb-doc
  "Executes forms in a context with code-var bound to each code-location in
   debug-block. This returns the value of executing result (defaults to nil)."
  (let ((code-locations (gensym))
	(i (gensym)))
    `(let ((,code-locations (debug-block-code-locations ,debug-block)))
       (declare (simple-vector ,code-locations))
       (dotimes (,i (length ,code-locations) ,return)
	 (let ((,code-var (svref ,code-locations ,i)))
	   ,@body)))))

(defun debug-block-function-name (debug-block)
  #!+sb-doc
  "Returns the name of the function represented by debug-function. This may
   be a string or a cons; do not assume it is a symbol."
  (etypecase debug-block
    (compiled-debug-block
     (let ((code-locs (compiled-debug-block-code-locations debug-block)))
       (declare (simple-vector code-locs))
       (if (zerop (length code-locs))
	   "??? Can't get name of debug-block's function."
	   (debug-function-name
	    (code-location-debug-function (svref code-locs 0))))))
    (interpreted-debug-block
     (sb!c::lambda-name (sb!c::block-home-lambda
			 (interpreted-debug-block-ir1-block debug-block))))))

(defun debug-block-code-locations (debug-block)
  (etypecase debug-block
    (compiled-debug-block
     (compiled-debug-block-code-locations debug-block))
    (interpreted-debug-block
     (interpreted-debug-block-code-locations debug-block))))

(defun interpreted-debug-block-code-locations (debug-block)
  (let ((code-locs (interpreted-debug-block-locations debug-block)))
    (if (eq code-locs :unparsed)
	(with-parsing-buffer (buf)
	  (sb!c::do-nodes (node cont (interpreted-debug-block-ir1-block
				   debug-block))
	    (vector-push-extend (make-interpreted-code-location
				 node
				 (make-interpreted-debug-function
				  (sb!c::block-home-lambda (sb!c::node-block
							    node))))
				buf))
	  (setf (interpreted-debug-block-locations debug-block)
		(result buf)))
	code-locs)))

;;;; operations on debug variables

(defun debug-var-symbol-name (debug-var)
  (symbol-name (debug-var-symbol debug-var)))

;;; FIXME: Make sure that this isn't called anywhere that it wouldn't
;;; be acceptable to have NIL returned, or that it's only called on
;;; DEBUG-VARs whose symbols have non-NIL packages.
(defun debug-var-package-name (debug-var)
  (package-name (symbol-package (debug-var-symbol debug-var))))

(defun debug-var-valid-value (debug-var frame)
  #!+sb-doc
  "Returns the value stored for DEBUG-VAR in frame. If the value is not
   :valid, then this signals an invalid-value error."
  (unless (eq (debug-var-validity debug-var (frame-code-location frame))
	      :valid)
    (error 'invalid-value :debug-var debug-var :frame frame))
  (debug-var-value debug-var frame))

(defun debug-var-value (debug-var frame)
  #!+sb-doc
  "Returns the value stored for DEBUG-VAR in frame. The value may be
   invalid. This is SETF'able."
  (etypecase debug-var
    (compiled-debug-var
     (check-type frame compiled-frame)
     (let ((res (access-compiled-debug-var-slot debug-var frame)))
       (if (indirect-value-cell-p res)
	   (sb!c:value-cell-ref res)
	   res)))
    (interpreted-debug-var
     (check-type frame interpreted-frame)
     (sb!eval::leaf-value-lambda-var
      (interpreted-code-location-ir1-node (frame-code-location frame))
      (interpreted-debug-var-ir1-var debug-var)
      (frame-pointer frame)
      (interpreted-frame-closure frame)))))

;;; This returns what is stored for the variable represented by
;;; DEBUG-VAR relative to the FRAME. This may be an indirect value
;;; cell if the variable is both closed over and set.
(defun access-compiled-debug-var-slot (debug-var frame)
  (let ((escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-access-debug-var-slot
	 (frame-pointer frame)
	 (compiled-debug-var-sc-offset debug-var)
	 escaped)
	(sub-access-debug-var-slot
	 (frame-pointer frame)
	 (or (compiled-debug-var-save-sc-offset debug-var)
	     (compiled-debug-var-sc-offset debug-var))))))

;;; a helper function for working with possibly-invalid values:
;;; Do (MAKE-LISP-OBJ VAL) only if the value looks valid.
;;;
;;; (Such values can arise in registers on machines with conservative
;;; GC, and might also arise in debug variable locations when
;;; those variables are invalid.)
(defun make-valid-lisp-obj (val)
  (/show0 "entering MAKE-VALID-LISP-OBJ, VAL=..")
  #!+sb-show (/hexstr val)
  (if (or
       ;; fixnum
       (zerop (logand val 3))
       ;; character
       (and (zerop (logand val #xffff0000)) ; Top bits zero
	    (= (logand val #xff) sb!vm:base-char-type)) ; Char tag
       ;; unbound marker
       (= val sb!vm:unbound-marker-type)
       ;; pointer
       (and (logand val 1)
	    ;; Check that the pointer is valid. XXX Could do a better
	    ;; job. FIXME: e.g. by calling out to an is_valid_pointer
	    ;; routine in the C runtime support code
	    (or (< sb!vm:read-only-space-start val
		   (* sb!vm:*read-only-space-free-pointer*
		      sb!vm:word-bytes))
		(< sb!vm:static-space-start val
		   (* sb!vm:*static-space-free-pointer*
		      sb!vm:word-bytes))
		(< sb!vm:dynamic-space-start val
		   (sap-int (dynamic-space-free-pointer))))))
      (make-lisp-obj val)
      :invalid-object))

;;; CMU CL had
;;;   (DEFUN SUB-ACCESS-DEBUG-VAR-SLOT (FP SC-OFFSET &OPTIONAL ESCAPED) ..)
;;; code for this case.
#!-x86
(eval-when (:compile-toplevel :load-toplevel :execute)
  (error "hopelessly stale"))

#!+x86
(defun sub-access-debug-var-slot (fp sc-offset &optional escaped)
  (declare (type system-area-pointer fp))
  (/show0 "entering SUB-ACCESS-DEBUG-VAR-SLOT, FP,SC-OFFSET,ESCAPED=..")
  (/hexstr fp) (/hexstr sc-offset) (/hexstr escaped)
  (macrolet ((with-escaped-value ((var) &body forms)
	       `(if escaped
		    (let ((,var (sb!vm:context-register
				 escaped
				 (sb!c:sc-offset-offset sc-offset))))
		      (/show0 "in escaped case, ,VAR value=..")
		      (/hexstr ,var)
		      ,@forms)
		    :invalid-value-for-unescaped-register-storage))
	     (escaped-float-value (format)
	       `(if escaped
		    (sb!vm:context-float-register
		     escaped (sb!c:sc-offset-offset sc-offset) ',format)
		    :invalid-value-for-unescaped-register-storage))
	     (escaped-complex-float-value (format)
	       `(if escaped
		    (complex
		     (sb!vm:context-float-register
		      escaped (sb!c:sc-offset-offset sc-offset) ',format)
		     (sb!vm:context-float-register
		      escaped (1+ (sb!c:sc-offset-offset sc-offset)) ',format))
		    :invalid-value-for-unescaped-register-storage)))
    (ecase (sb!c:sc-offset-scn sc-offset)
      ((#.sb!vm:any-reg-sc-number #.sb!vm:descriptor-reg-sc-number)
       (/show0 "case of ANY-REG-SC-NUMBER or DESCRIPTOR-REG-SC-NUMBER")
       (without-gcing
	(with-escaped-value (val)
	  (/show0 "VAL=..")
	  (/hexstr val)
	  (make-valid-lisp-obj val))))
      (#.sb!vm:base-char-reg-sc-number
       (/show0 "case of BASE-CHAR-REG-SC-NUMBER")
       (with-escaped-value (val)
	 (code-char val)))
      (#.sb!vm:sap-reg-sc-number
       (/show0 "case of SAP-REG-SC-NUMBER")
       (with-escaped-value (val)
	 (int-sap val)))
      (#.sb!vm:signed-reg-sc-number
       (/show0 "case of SIGNED-REG-SC-NUMBER")
       (with-escaped-value (val)
	 (if (logbitp (1- sb!vm:word-bits) val)
	     (logior val (ash -1 sb!vm:word-bits))
	     val)))
      (#.sb!vm:unsigned-reg-sc-number
       (/show0 "case of UNSIGNED-REG-SC-NUMBER")
       (with-escaped-value (val)
	 val))
      (#.sb!vm:single-reg-sc-number
       (/show0 "case of SINGLE-REG-SC-NUMBER")
       (escaped-float-value single-float))
      (#.sb!vm:double-reg-sc-number
       (/show0 "case of DOUBLE-REG-SC-NUMBER")
       (escaped-float-value double-float))
      #!+long-float
      (#.sb!vm:long-reg-sc-number
       (/show0 "case of LONG-REG-SC-NUMBER")
       (escaped-float-value long-float))
      (#.sb!vm:complex-single-reg-sc-number
       (/show0 "case of COMPLEX-SINGLE-REG-SC-NUMBER")
       (escaped-complex-float-value single-float))
      (#.sb!vm:complex-double-reg-sc-number
       (/show0 "case of COMPLEX-DOUBLE-REG-SC-NUMBER")
       (escaped-complex-float-value double-float))
      #!+long-float
      (#.sb!vm:complex-long-reg-sc-number
       (/show0 "case of COMPLEX-LONG-REG-SC-NUMBER")
       (escaped-complex-float-value long-float))
      (#.sb!vm:single-stack-sc-number
       (/show0 "case of SINGLE-STACK-SC-NUMBER")
       (sap-ref-single fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
				sb!vm:word-bytes))))
      (#.sb!vm:double-stack-sc-number
       (/show0 "case of DOUBLE-STACK-SC-NUMBER")
       (sap-ref-double fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 2)
				sb!vm:word-bytes))))
      #!+long-float
      (#.sb!vm:long-stack-sc-number
       (/show0 "case of LONG-STACK-SC-NUMBER")
       (sap-ref-long fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 3)
			      sb!vm:word-bytes))))
      (#.sb!vm:complex-single-stack-sc-number
       (/show0 "case of COMPLEX-STACK-SC-NUMBER")
       (complex
	(sap-ref-single fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
				 sb!vm:word-bytes)))
	(sap-ref-single fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 2)
				 sb!vm:word-bytes)))))
      (#.sb!vm:complex-double-stack-sc-number
       (/show0 "case of COMPLEX-DOUBLE-STACK-SC-NUMBER")
       (complex
	(sap-ref-double fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 2)
				 sb!vm:word-bytes)))
	(sap-ref-double fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 4)
				 sb!vm:word-bytes)))))
      #!+long-float
      (#.sb!vm:complex-long-stack-sc-number
       (/show0 "case of COMPLEX-LONG-STACK-SC-NUMBER")
       (complex
	(sap-ref-long fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 3)
			       sb!vm:word-bytes)))
	(sap-ref-long fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 6)
			       sb!vm:word-bytes)))))
      (#.sb!vm:control-stack-sc-number
       (/show0 "case of CONTROL-STACK-SC-NUMBER")
       (stack-ref fp (sb!c:sc-offset-offset sc-offset)))
      (#.sb!vm:base-char-stack-sc-number
       (/show0 "case of BASE-CHAR-STACK-SC-NUMBER")
       (code-char
	(sap-ref-32 fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
			     sb!vm:word-bytes)))))
      (#.sb!vm:unsigned-stack-sc-number
       (/show0 "case of UNSIGNED-STACK-SC-NUMBER")
       (sap-ref-32 fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
			    sb!vm:word-bytes))))
      (#.sb!vm:signed-stack-sc-number
       (/show0 "case of SIGNED-STACK-SC-NUMBER")
       (signed-sap-ref-32 fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
				   sb!vm:word-bytes))))
      (#.sb!vm:sap-stack-sc-number
       (/show0 "case of SAP-STACK-SC-NUMBER")
       (sap-ref-sap fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
			     sb!vm:word-bytes)))))))

;;; This stores value as the value of DEBUG-VAR in FRAME. In the
;;; COMPILED-DEBUG-VAR case, access the current value to determine if
;;; it is an indirect value cell. This occurs when the variable is
;;; both closed over and set. For INTERPRETED-DEBUG-VARs just call
;;; SB!EVAL::SET-LEAF-VALUE-LAMBDA-VAR with the right interpreter
;;; objects.
(defun %set-debug-var-value (debug-var frame value)
  (etypecase debug-var
    (compiled-debug-var
     (check-type frame compiled-frame)
     (let ((current-value (access-compiled-debug-var-slot debug-var frame)))
       (if (indirect-value-cell-p current-value)
	   (sb!c:value-cell-set current-value value)
	   (set-compiled-debug-var-slot debug-var frame value))))
    (interpreted-debug-var
     (check-type frame interpreted-frame)
     (sb!eval::set-leaf-value-lambda-var
      (interpreted-code-location-ir1-node (frame-code-location frame))
      (interpreted-debug-var-ir1-var debug-var)
      (frame-pointer frame)
      (interpreted-frame-closure frame)
      value)))
  value)

;;; This stores value for the variable represented by debug-var
;;; relative to the frame. This assumes the location directly contains
;;; the variable's value; that is, there is no indirect value cell
;;; currently there in case the variable is both closed over and set.
(defun set-compiled-debug-var-slot (debug-var frame value)
  (let ((escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-set-debug-var-slot (frame-pointer frame)
				(compiled-debug-var-sc-offset debug-var)
				value escaped)
	(sub-set-debug-var-slot
	 (frame-pointer frame)
	 (or (compiled-debug-var-save-sc-offset debug-var)
	     (compiled-debug-var-sc-offset debug-var))
	 value))))

#!-x86
(defun sub-set-debug-var-slot (fp sc-offset value &optional escaped)
  (macrolet ((set-escaped-value (val)
	       `(if escaped
		    (setf (sb!vm:context-register
			   escaped
			   (sb!c:sc-offset-offset sc-offset))
			  ,val)
		    value))
	     (set-escaped-float-value (format val)
	       `(if escaped
		    (setf (sb!vm:context-float-register
			   escaped
			   (sb!c:sc-offset-offset sc-offset)
			   ',format)
			  ,val)
		    value))
	     (with-nfp ((var) &body body)
	       `(let ((,var (if escaped
				(int-sap
				 (sb!vm:context-register escaped
							 sb!vm::nfp-offset))
				#!-alpha
				(sap-ref-sap fp
						    (* sb!vm::nfp-save-offset
						       sb!vm:word-bytes))
				#!+alpha
				(%alpha::make-number-stack-pointer
				 (sap-ref-32 fp
						    (* sb!vm::nfp-save-offset
						       sb!vm:word-bytes))))))
		  ,@body)))
    (ecase (sb!c:sc-offset-scn sc-offset)
      ((#.sb!vm:any-reg-sc-number
	#.sb!vm:descriptor-reg-sc-number
	#!+rt #.sb!vm:word-pointer-reg-sc-number)
       (without-gcing
	(set-escaped-value
	  (get-lisp-obj-address value))))
      (#.sb!vm:base-char-reg-sc-number
       (set-escaped-value (char-code value)))
      (#.sb!vm:sap-reg-sc-number
       (set-escaped-value (sap-int value)))
      (#.sb!vm:signed-reg-sc-number
       (set-escaped-value (logand value (1- (ash 1 sb!vm:word-bits)))))
      (#.sb!vm:unsigned-reg-sc-number
       (set-escaped-value value))
      (#.sb!vm:non-descriptor-reg-sc-number
       (error "Local non-descriptor register access?"))
      (#.sb!vm:interior-reg-sc-number
       (error "Local interior register access?"))
      (#.sb!vm:single-reg-sc-number
       (set-escaped-float-value single-float value))
      (#.sb!vm:double-reg-sc-number
       (set-escaped-float-value double-float value))
      #!+long-float
      (#.sb!vm:long-reg-sc-number
       (set-escaped-float-value long-float value))
      (#.sb!vm:complex-single-reg-sc-number
       (when escaped
	 (setf (sb!vm:context-float-register escaped
					     (sb!c:sc-offset-offset sc-offset)
					     'single-float)
	       (realpart value))
	 (setf (sb!vm:context-float-register
		escaped (1+ (sb!c:sc-offset-offset sc-offset))
		'single-float)
	       (imagpart value)))
       value)
      (#.sb!vm:complex-double-reg-sc-number
       (when escaped
	 (setf (sb!vm:context-float-register
		escaped (sb!c:sc-offset-offset sc-offset) 'double-float)
	       (realpart value))
	 (setf (sb!vm:context-float-register
		escaped
		(+ (sb!c:sc-offset-offset sc-offset) #!+sparc 2 #!-sparc 1)
		'double-float)
	       (imagpart value)))
       value)
      #!+long-float
      (#.sb!vm:complex-long-reg-sc-number
       (when escaped
	 (setf (sb!vm:context-float-register
		escaped (sb!c:sc-offset-offset sc-offset) 'long-float)
	       (realpart value))
	 (setf (sb!vm:context-float-register
		escaped
		(+ (sb!c:sc-offset-offset sc-offset) #!+sparc 4)
		'long-float)
	       (imagpart value)))
       value)
      (#.sb!vm:single-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-single nfp (* (sb!c:sc-offset-offset sc-offset)
				      sb!vm:word-bytes))
	       (the single-float value))))
      (#.sb!vm:double-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-double nfp (* (sb!c:sc-offset-offset sc-offset)
				      sb!vm:word-bytes))
	       (the double-float value))))
      #!+long-float
      (#.sb!vm:long-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-long nfp (* (sb!c:sc-offset-offset sc-offset)
				    sb!vm:word-bytes))
	       (the long-float value))))
      (#.sb!vm:complex-single-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-single
		nfp (* (sb!c:sc-offset-offset sc-offset) sb!vm:word-bytes))
	       (the single-float (realpart value)))
	 (setf (sap-ref-single
		nfp (* (1+ (sb!c:sc-offset-offset sc-offset))
		       sb!vm:word-bytes))
	       (the single-float (realpart value)))))
      (#.sb!vm:complex-double-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-double
		nfp (* (sb!c:sc-offset-offset sc-offset) sb!vm:word-bytes))
	       (the double-float (realpart value)))
	 (setf (sap-ref-double
		nfp (* (+ (sb!c:sc-offset-offset sc-offset) 2)
		       sb!vm:word-bytes))
	       (the double-float (realpart value)))))
      #!+long-float
      (#.sb!vm:complex-long-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-long
		nfp (* (sb!c:sc-offset-offset sc-offset) sb!vm:word-bytes))
	       (the long-float (realpart value)))
	 (setf (sap-ref-long
		nfp (* (+ (sb!c:sc-offset-offset sc-offset) #!+sparc 4)
		       sb!vm:word-bytes))
	       (the long-float (realpart value)))))
      (#.sb!vm:control-stack-sc-number
       (setf (stack-ref fp (sb!c:sc-offset-offset sc-offset)) value))
      (#.sb!vm:base-char-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-32 nfp (* (sb!c:sc-offset-offset sc-offset)
					 sb!vm:word-bytes))
	       (char-code (the character value)))))
      (#.sb!vm:unsigned-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-32 nfp (* (sb!c:sc-offset-offset sc-offset)
				  sb!vm:word-bytes))
	       (the (unsigned-byte 32) value))))
      (#.sb!vm:signed-stack-sc-number
       (with-nfp (nfp)
	 (setf (signed-sap-ref-32 nfp (* (sb!c:sc-offset-offset sc-offset)
					 sb!vm:word-bytes))
	       (the (signed-byte 32) value))))
      (#.sb!vm:sap-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-sap nfp (* (sb!c:sc-offset-offset sc-offset)
				   sb!vm:word-bytes))
	       (the system-area-pointer value)))))))

#!+x86
(defun sub-set-debug-var-slot (fp sc-offset value &optional escaped)
  (macrolet ((set-escaped-value (val)
	       `(if escaped
		    (setf (sb!vm:context-register
			   escaped
			   (sb!c:sc-offset-offset sc-offset))
			  ,val)
		    value)))
    (ecase (sb!c:sc-offset-scn sc-offset)
      ((#.sb!vm:any-reg-sc-number #.sb!vm:descriptor-reg-sc-number)
       (without-gcing
	(set-escaped-value
	  (get-lisp-obj-address value))))
      (#.sb!vm:base-char-reg-sc-number
       (set-escaped-value (char-code value)))
      (#.sb!vm:sap-reg-sc-number
       (set-escaped-value (sap-int value)))
      (#.sb!vm:signed-reg-sc-number
       (set-escaped-value (logand value (1- (ash 1 sb!vm:word-bits)))))
      (#.sb!vm:unsigned-reg-sc-number
       (set-escaped-value value))
      (#.sb!vm:single-reg-sc-number
	#+nil ;; don't have escaped floats.
       (set-escaped-float-value single-float value))
      (#.sb!vm:double-reg-sc-number
	#+nil ;;  don't have escaped floats -- still in npx?
       (set-escaped-float-value double-float value))
      #!+long-float
      (#.sb!vm:long-reg-sc-number
	#+nil ;;  don't have escaped floats -- still in npx?
       (set-escaped-float-value long-float value))
      (#.sb!vm:single-stack-sc-number
       (setf (sap-ref-single
	      fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
		       sb!vm:word-bytes)))
	     (the single-float value)))
      (#.sb!vm:double-stack-sc-number
       (setf (sap-ref-double
	      fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 2)
		       sb!vm:word-bytes)))
	     (the double-float value)))
      #!+long-float
      (#.sb!vm:long-stack-sc-number
       (setf (sap-ref-long
	      fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 3)
		       sb!vm:word-bytes)))
	     (the long-float value)))
      (#.sb!vm:complex-single-stack-sc-number
       (setf (sap-ref-single
	      fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
		       sb!vm:word-bytes)))
	     (realpart (the (complex single-float) value)))
       (setf (sap-ref-single
	      fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 2)
		       sb!vm:word-bytes)))
	     (imagpart (the (complex single-float) value))))
      (#.sb!vm:complex-double-stack-sc-number
       (setf (sap-ref-double
	      fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 2)
		       sb!vm:word-bytes)))
	     (realpart (the (complex double-float) value)))
       (setf (sap-ref-double
	      fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 4)
		       sb!vm:word-bytes)))
	     (imagpart (the (complex double-float) value))))
      #!+long-float
      (#.sb!vm:complex-long-stack-sc-number
       (setf (sap-ref-long
	      fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 3)
		       sb!vm:word-bytes)))
	     (realpart (the (complex long-float) value)))
       (setf (sap-ref-long
	      fp (- (* (+ (sb!c:sc-offset-offset sc-offset) 6)
		       sb!vm:word-bytes)))
	     (imagpart (the (complex long-float) value))))
      (#.sb!vm:control-stack-sc-number
       (setf (stack-ref fp (sb!c:sc-offset-offset sc-offset)) value))
      (#.sb!vm:base-char-stack-sc-number
       (setf (sap-ref-32 fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
					 sb!vm:word-bytes)))
	     (char-code (the character value))))
      (#.sb!vm:unsigned-stack-sc-number
       (setf (sap-ref-32 fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
					 sb!vm:word-bytes)))
	     (the (unsigned-byte 32) value)))
      (#.sb!vm:signed-stack-sc-number
       (setf (signed-sap-ref-32
	      fp (- (* (1+ (sb!c:sc-offset-offset sc-offset)) sb!vm:word-bytes)))
	     (the (signed-byte 32) value)))
      (#.sb!vm:sap-stack-sc-number
       (setf (sap-ref-sap fp (- (* (1+ (sb!c:sc-offset-offset sc-offset))
					  sb!vm:word-bytes)))
	     (the system-area-pointer value))))))

;;; The method for setting and accessing COMPILED-DEBUG-VAR values use
;;; this to determine if the value stored is the actual value or an
;;; indirection cell.
(defun indirect-value-cell-p (x)
  (and (= (get-lowtag x) sb!vm:other-pointer-type)
       (= (get-type x) sb!vm:value-cell-header-type)))

;;; If the variable is always alive, then it is valid. If the
;;; code-location is unknown, then the variable's validity is
;;; :unknown. Once we've called CODE-LOCATION-UNKNOWN-P, we know the
;;; live-set information has been cached in the code-location.
(defun debug-var-validity (debug-var basic-code-location)
  #!+sb-doc
  "Returns three values reflecting the validity of DEBUG-VAR's value
   at BASIC-CODE-LOCATION:
      :VALID    The value is known to be available.
      :INVALID  The value is known to be unavailable.
      :UNKNOWN  The value's availability is unknown."
  (etypecase debug-var
    (compiled-debug-var
     (compiled-debug-var-validity debug-var basic-code-location))
    (interpreted-debug-var
     (check-type basic-code-location interpreted-code-location)
     (let ((validp (rassoc (interpreted-debug-var-ir1-var debug-var)
			   (sb!c::lexenv-variables
			    (sb!c::node-lexenv
			     (interpreted-code-location-ir1-node
			      basic-code-location))))))
       (if validp :valid :invalid)))))

;;; This is the method for DEBUG-VAR-VALIDITY for COMPILED-DEBUG-VARs.
;;; For safety, make sure basic-code-location is what we think.
(defun compiled-debug-var-validity (debug-var basic-code-location)
  (check-type basic-code-location compiled-code-location)
  (cond ((debug-var-alive-p debug-var)
	 (let ((debug-fun (code-location-debug-function basic-code-location)))
	   (if (>= (compiled-code-location-pc basic-code-location)
		   (sb!c::compiled-debug-function-start-pc
		    (compiled-debug-function-compiler-debug-fun debug-fun)))
	       :valid
	       :invalid)))
	((code-location-unknown-p basic-code-location) :unknown)
	(t
	 (let ((pos (position debug-var
			      (debug-function-debug-vars
			       (code-location-debug-function basic-code-location)))))
	   (unless pos
	     (error 'unknown-debug-var
		    :debug-var debug-var
		    :debug-function
		    (code-location-debug-function basic-code-location)))
	   ;; There must be live-set info since basic-code-location is known.
	   (if (zerop (sbit (compiled-code-location-live-set basic-code-location)
			    pos))
	       :invalid
	       :valid)))))

;;;; sources

;;; This code produces and uses what we call source-paths. A
;;; source-path is a list whose first element is a form number as
;;; returned by CODE-LOCATION-FORM-NUMBER and whose last element is a
;;; top-level-form number as returned by
;;; CODE-LOCATION-TOP-LEVEL-FORM-NUMBER. The elements from the last to
;;; the first, exclusively, are the numbered subforms into which to
;;; descend. For example:
;;;    (defun foo (x)
;;;      (let ((a (aref x 3)))
;;;	(cons a 3)))
;;; The call to AREF in this example is form number 5. Assuming this
;;; DEFUN is the 11'th top-level-form, the source-path for the AREF
;;; call is as follows:
;;;    (5 1 0 1 3 11)
;;; Given the DEFUN, 3 gets you the LET, 1 gets you the bindings, 0
;;; gets the first binding, and 1 gets the AREF form.

;;; Temporary buffer used to build form-number => source-path translation in
;;; FORM-NUMBER-TRANSLATIONS.
(defvar *form-number-temp* (make-array 10 :fill-pointer 0 :adjustable t))

;;; Table used to detect CAR circularities in FORM-NUMBER-TRANSLATIONS.
(defvar *form-number-circularity-table* (make-hash-table :test 'eq))

;;; The vector elements are in the same format as the compiler's
;;; NODE-SOUCE-PATH; that is, the first element is the form number and the last
;;; is the top-level-form number.
(defun form-number-translations (form tlf-number)
  #!+sb-doc
  "This returns a table mapping form numbers to source-paths. A source-path
   indicates a descent into the top-level-form form, going directly to the
   subform corressponding to the form number."
  (clrhash *form-number-circularity-table*)
  (setf (fill-pointer *form-number-temp*) 0)
  (sub-translate-form-numbers form (list tlf-number))
  (coerce *form-number-temp* 'simple-vector))
(defun sub-translate-form-numbers (form path)
  (unless (gethash form *form-number-circularity-table*)
    (setf (gethash form *form-number-circularity-table*) t)
    (vector-push-extend (cons (fill-pointer *form-number-temp*) path)
			*form-number-temp*)
    (let ((pos 0)
	  (subform form)
	  (trail form))
      (declare (fixnum pos))
      (macrolet ((frob ()
		   '(progn
		      (when (atom subform) (return))
		      (let ((fm (car subform)))
			(when (consp fm)
			  (sub-translate-form-numbers fm (cons pos path)))
			(incf pos))
		      (setq subform (cdr subform))
		      (when (eq subform trail) (return)))))
	(loop
	  (frob)
	  (frob)
	  (setq trail (cdr trail)))))))

(defun source-path-context (form path context)
  #!+sb-doc
  "Form is a top-level form, and path is a source-path into it. This returns
   the form indicated by the source-path. Context is the number of enclosing
   forms to return instead of directly returning the source-path form. When
   context is non-zero, the form returned contains a marker, #:****HERE****,
   immediately before the form indicated by path."
  (declare (type unsigned-byte context))
  ;; Get to the form indicated by path or the enclosing form indicated
  ;; by context and path.
  (let ((path (reverse (butlast (cdr path)))))
    (dotimes (i (- (length path) context))
      (let ((index (first path)))
	(unless (and (listp form) (< index (length form)))
	  (error "Source path no longer exists."))
	(setq form (elt form index))
	(setq path (rest path))))
    ;; Recursively rebuild the source form resulting from the above
    ;; descent, copying the beginning of each subform up to the next
    ;; subform we descend into according to path. At the bottom of the
    ;; recursion, we return the form indicated by path preceded by our
    ;; marker, and this gets spliced into the resulting list structure
    ;; on the way back up.
    (labels ((frob (form path level)
	       (if (or (zerop level) (null path))
		   (if (zerop context)
		       form
		       `(#:***here*** ,form))
		   (let ((n (first path)))
		     (unless (and (listp form) (< n (length form)))
		       (error "Source path no longer exists."))
		     (let ((res (frob (elt form n) (rest path) (1- level))))
		       (nconc (subseq form 0 n)
			      (cons res (nthcdr (1+ n) form))))))))
      (frob form path context))))

;;;; PREPROCESS-FOR-EVAL and EVAL-IN-FRAME

;;; Create a SYMBOL-MACROLET for each variable valid at the location which
;;; accesses that variable from the frame argument.
(defun preprocess-for-eval (form loc)
  #!+sb-doc
  "Return a function of one argument that evaluates form in the lexical
   context of the basic-code-location loc. PREPROCESS-FOR-EVAL signals a
   no-debug-vars condition when the loc's debug-function has no
   debug-var information available. The returned function takes the frame
   to get values from as its argument, and it returns the values of form.
   The returned function signals the following conditions: invalid-value,
   ambiguous-variable-name, and frame-function-mismatch"
  (declare (type code-location loc))
  (let ((n-frame (gensym))
	(fun (code-location-debug-function loc)))
    (unless (debug-var-info-available fun)
      (debug-signal 'no-debug-vars :debug-function fun))
    (sb!int:collect ((binds)
		     (specs))
      (do-debug-function-variables (var fun)
	(let ((validity (debug-var-validity var loc)))
	  (unless (eq validity :invalid)
	    (let* ((sym (debug-var-symbol var))
		   (found (assoc sym (binds))))
	      (if found
		  (setf (second found) :ambiguous)
		  (binds (list sym validity var)))))))
      (dolist (bind (binds))
	(let ((name (first bind))
	      (var (third bind)))
	  (ecase (second bind)
	    (:valid
	     (specs `(,name (debug-var-value ',var ,n-frame))))
	    (:unknown
	     (specs `(,name (debug-signal 'invalid-value :debug-var ',var
					  :frame ,n-frame))))
	    (:ambiguous
	     (specs `(,name (debug-signal 'ambiguous-variable-name :name ',name
					  :frame ,n-frame)))))))
      (let ((res (coerce `(lambda (,n-frame)
			    (declare (ignorable ,n-frame))
			    (symbol-macrolet ,(specs) ,form))
			 'function)))
	#'(lambda (frame)
	    ;; This prevents these functions from being used in any
	    ;; location other than a function return location, so
	    ;; maybe this should only check whether frame's
	    ;; debug-function is the same as loc's.
	    (unless (code-location= (frame-code-location frame) loc)
	      (debug-signal 'frame-function-mismatch
			    :code-location loc :form form :frame frame))
	    (funcall res frame))))))

;;; Evaluate FORM in the lexical context of FRAME's current code
;;; location, returning the results of the evaluation.
(defun eval-in-frame (frame form)
  (declare (type frame frame))
  (funcall (preprocess-for-eval form (frame-code-location frame)) frame))

;;;; breakpoints

;;;; user-visible interface

;;; Create and return a breakpoint. When program execution encounters
;;; the breakpoint, the system calls HOOK-FUNCTION. HOOK-FUNCTION takes the
;;; current frame for the function in which the program is running and the
;;; breakpoint object.
;;;
;;; WHAT and KIND determine where in a function the system invokes
;;; HOOK-FUNCTION. WHAT is either a code-location or a debug-function.
;;; KIND is one of :CODE-LOCATION, :FUNCTION-START, or :FUNCTION-END.
;;; Since the starts and ends of functions may not have code-locations
;;; representing them, designate these places by supplying WHAT as a
;;; debug-function and KIND indicating the :FUNCTION-START or
;;; :FUNCTION-END. When WHAT is a debug-function and kind is
;;; :FUNCTION-END, then hook-function must take two additional
;;; arguments, a list of values returned by the function and a
;;; FUNCTION-END-COOKIE.
;;;
;;; INFO is information supplied by and used by the user.
;;;
;;; FUNCTION-END-COOKIE is a function. To implement :FUNCTION-END
;;; breakpoints, the system uses starter breakpoints to establish the
;;; :FUNCTION-END breakpoint for each invocation of the function. Upon
;;; each entry, the system creates a unique cookie to identify the
;;; invocation, and when the user supplies a function for this
;;; argument, the system invokes it on the frame and the cookie. The
;;; system later invokes the :FUNCTION-END breakpoint hook on the same
;;; cookie. The user may save the cookie for comparison in the hook
;;; function.
;;;
;;; Signal an error if WHAT is an unknown code-location.
(defun make-breakpoint (hook-function what
			&key (kind :code-location) info function-end-cookie)
  (etypecase what
    (code-location
     (when (code-location-unknown-p what)
       (error "cannot make a breakpoint at an unknown code location: ~S"
	      what))
     (aver (eq kind :code-location))
     (let ((bpt (%make-breakpoint hook-function what kind info)))
       (etypecase what
	 (interpreted-code-location
	  (error "Breakpoints in interpreted code are currently unsupported."))
	 (compiled-code-location
	  ;; This slot is filled in due to calling CODE-LOCATION-UNKNOWN-P.
	  (when (eq (compiled-code-location-kind what) :unknown-return)
	    (let ((other-bpt (%make-breakpoint hook-function what
					       :unknown-return-partner
					       info)))
	      (setf (breakpoint-unknown-return-partner bpt) other-bpt)
	      (setf (breakpoint-unknown-return-partner other-bpt) bpt)))))
       bpt))
    (compiled-debug-function
     (ecase kind
       (:function-start
	(%make-breakpoint hook-function what kind info))
       (:function-end
	(unless (eq (sb!c::compiled-debug-function-returns
		     (compiled-debug-function-compiler-debug-fun what))
		    :standard)
	  (error ":FUNCTION-END breakpoints are currently unsupported ~
		  for the known return convention."))

	(let* ((bpt (%make-breakpoint hook-function what kind info))
	       (starter (compiled-debug-function-end-starter what)))
	  (unless starter
	    (setf starter (%make-breakpoint #'list what :function-start nil))
	    (setf (breakpoint-hook-function starter)
		  (function-end-starter-hook starter what))
	    (setf (compiled-debug-function-end-starter what) starter))
	  (setf (breakpoint-start-helper bpt) starter)
	  (push bpt (breakpoint-%info starter))
	  (setf (breakpoint-cookie-fun bpt) function-end-cookie)
	  bpt))))
    (interpreted-debug-function
     (error ":function-end breakpoints are currently unsupported ~
	     for interpreted-debug-functions."))))

;;; These are unique objects created upon entry into a function by a
;;; :FUNCTION-END breakpoint's starter hook. These are only created
;;; when users supply :FUNCTION-END-COOKIE to MAKE-BREAKPOINT. Also,
;;; the :FUNCTION-END breakpoint's hook is called on the same cookie
;;; when it is created.
(defstruct (function-end-cookie
	    (:print-object (lambda (obj str)
			     (print-unreadable-object (obj str :type t))))
	    (:constructor make-function-end-cookie (bogus-lra debug-fun))
	    (:copier nil))
  ;; a pointer to the bogus-lra created for :FUNCTION-END breakpoints
  bogus-lra
  ;; the debug-function associated with the cookie
  debug-fun)

;;; This maps bogus-lra-components to cookies, so that
;;; HANDLE-FUNCTION-END-BREAKPOINT can find the appropriate cookie for the
;;; breakpoint hook.
(defvar *function-end-cookies* (make-hash-table :test 'eq))

;;; This returns a hook function for the start helper breakpoint
;;; associated with a :FUNCTION-END breakpoint. The returned function
;;; makes a fake LRA that all returns go through, and this piece of
;;; fake code actually breaks. Upon return from the break, the code
;;; provides the returnee with any values. Since the returned function
;;; effectively activates FUN-END-BPT on each entry to DEBUG-FUN's
;;; function, we must establish breakpoint-data about FUN-END-BPT.
(defun function-end-starter-hook (starter-bpt debug-fun)
  (declare (type breakpoint starter-bpt)
	   (type compiled-debug-function debug-fun))
  #'(lambda (frame breakpoint)
      (declare (ignore breakpoint)
	       (type frame frame))
      (let ((lra-sc-offset
	     (sb!c::compiled-debug-function-return-pc
	      (compiled-debug-function-compiler-debug-fun debug-fun))))
	(multiple-value-bind (lra component offset)
	    (make-bogus-lra
	     (get-context-value frame
				#!-gengc sb!vm::lra-save-offset
				#!+gengc sb!vm::ra-save-offset
				lra-sc-offset))
	  (setf (get-context-value frame
				   #!-gengc sb!vm::lra-save-offset
				   #!+gengc sb!vm::ra-save-offset
				   lra-sc-offset)
		lra)
	  (let ((end-bpts (breakpoint-%info starter-bpt)))
	    (let ((data (breakpoint-data component offset)))
	      (setf (breakpoint-data-breakpoints data) end-bpts)
	      (dolist (bpt end-bpts)
		(setf (breakpoint-internal-data bpt) data)))
	    (let ((cookie (make-function-end-cookie lra debug-fun)))
	      (setf (gethash component *function-end-cookies*) cookie)
	      (dolist (bpt end-bpts)
		(let ((fun (breakpoint-cookie-fun bpt)))
		  (when fun (funcall fun frame cookie))))))))))

;;; This takes a FUNCTION-END-COOKIE and a frame, and it returns
;;; whether the cookie is still valid. A cookie becomes invalid when
;;; the frame that established the cookie has exited. Sometimes cookie
;;; holders are unaware of cookie invalidation because their
;;; :FUNCTION-END breakpoint hooks didn't run due to THROW'ing.
;;;
;;; This takes a frame as an efficiency hack since the user probably
;;; has a frame object in hand when using this routine, and it saves
;;; repeated parsing of the stack and consing when asking whether a
;;; series of cookies is valid.
(defun function-end-cookie-valid-p (frame cookie)
  (let ((lra (function-end-cookie-bogus-lra cookie))
	(lra-sc-offset (sb!c::compiled-debug-function-return-pc
			(compiled-debug-function-compiler-debug-fun
			 (function-end-cookie-debug-fun cookie)))))
    (do ((frame frame (frame-down frame)))
	((not frame) nil)
      (when (and (compiled-frame-p frame)
		 (eq lra
		     (get-context-value frame
					#!-gengc sb!vm::lra-save-offset
					#!+gengc sb!vm::ra-save-offset
					lra-sc-offset)))
	(return t)))))

;;;; ACTIVATE-BREAKPOINT

;;; Cause the system to invoke the breakpoint's hook-function until
;;; the next call to DEACTIVATE-BREAKPOINT or DELETE-BREAKPOINT. The
;;; system invokes breakpoint hook functions in the opposite order
;;; that you activate them.
(defun activate-breakpoint (breakpoint)
  (when (eq (breakpoint-status breakpoint) :deleted)
    (error "cannot activate a deleted breakpoint: ~S" breakpoint))
  (unless (eq (breakpoint-status breakpoint) :active)
    (ecase (breakpoint-kind breakpoint)
      (:code-location
       (let ((loc (breakpoint-what breakpoint)))
	 (etypecase loc
	   (interpreted-code-location
	    (error "Breakpoints in interpreted code are currently unsupported."))
	   (compiled-code-location
	    (activate-compiled-code-location-breakpoint breakpoint)
	    (let ((other (breakpoint-unknown-return-partner breakpoint)))
	      (when other
		(activate-compiled-code-location-breakpoint other)))))))
      (:function-start
       (etypecase (breakpoint-what breakpoint)
	 (compiled-debug-function
	  (activate-compiled-function-start-breakpoint breakpoint))
	 (interpreted-debug-function
	  (error "I don't know how you made this, but they're unsupported: ~S"
		 (breakpoint-what breakpoint)))))
      (:function-end
       (etypecase (breakpoint-what breakpoint)
	 (compiled-debug-function
	  (let ((starter (breakpoint-start-helper breakpoint)))
	    (unless (eq (breakpoint-status starter) :active)
	      ;; may already be active by some other :FUNCTION-END breakpoint
	      (activate-compiled-function-start-breakpoint starter)))
	  (setf (breakpoint-status breakpoint) :active))
	 (interpreted-debug-function
	  (error "I don't know how you made this, but they're unsupported: ~S"
		 (breakpoint-what breakpoint)))))))
  breakpoint)

(defun activate-compiled-code-location-breakpoint (breakpoint)
  (declare (type breakpoint breakpoint))
  (let ((loc (breakpoint-what breakpoint)))
    (declare (type compiled-code-location loc))
    (sub-activate-breakpoint
     breakpoint
     (breakpoint-data (compiled-debug-function-component
		       (code-location-debug-function loc))
		      (+ (compiled-code-location-pc loc)
			 (if (or (eq (breakpoint-kind breakpoint)
				     :unknown-return-partner)
				 (eq (compiled-code-location-kind loc)
				     :single-value-return))
			     sb!vm:single-value-return-byte-offset
			     0))))))

(defun activate-compiled-function-start-breakpoint (breakpoint)
  (declare (type breakpoint breakpoint))
  (let ((debug-fun (breakpoint-what breakpoint)))
    (sub-activate-breakpoint
     breakpoint
     (breakpoint-data (compiled-debug-function-component debug-fun)
		      (sb!c::compiled-debug-function-start-pc
		       (compiled-debug-function-compiler-debug-fun
			debug-fun))))))

(defun sub-activate-breakpoint (breakpoint data)
  (declare (type breakpoint breakpoint)
	   (type breakpoint-data data))
  (setf (breakpoint-status breakpoint) :active)
  (without-interrupts
   (unless (breakpoint-data-breakpoints data)
     (setf (breakpoint-data-instruction data)
	   (without-gcing
	    (breakpoint-install (get-lisp-obj-address
				 (breakpoint-data-component data))
				(breakpoint-data-offset data)))))
   (setf (breakpoint-data-breakpoints data)
	 (append (breakpoint-data-breakpoints data) (list breakpoint)))
   (setf (breakpoint-internal-data breakpoint) data)))

;;;; DEACTIVATE-BREAKPOINT

(defun deactivate-breakpoint (breakpoint)
  #!+sb-doc
  "This stops the system from invoking the breakpoint's hook-function."
  (when (eq (breakpoint-status breakpoint) :active)
    (without-interrupts
     (let ((loc (breakpoint-what breakpoint)))
       (etypecase loc
	 ((or interpreted-code-location interpreted-debug-function)
	  (error
	   "Breakpoints in interpreted code are currently unsupported."))
	 ((or compiled-code-location compiled-debug-function)
	  (deactivate-compiled-breakpoint breakpoint)
	  (let ((other (breakpoint-unknown-return-partner breakpoint)))
	    (when other
	      (deactivate-compiled-breakpoint other))))))))
  breakpoint)

(defun deactivate-compiled-breakpoint (breakpoint)
  (if (eq (breakpoint-kind breakpoint) :function-end)
      (let ((starter (breakpoint-start-helper breakpoint)))
	(unless (find-if #'(lambda (bpt)
			     (and (not (eq bpt breakpoint))
				  (eq (breakpoint-status bpt) :active)))
			 (breakpoint-%info starter))
	  (deactivate-compiled-breakpoint starter)))
      (let* ((data (breakpoint-internal-data breakpoint))
	     (bpts (delete breakpoint (breakpoint-data-breakpoints data))))
	(setf (breakpoint-internal-data breakpoint) nil)
	(setf (breakpoint-data-breakpoints data) bpts)
	(unless bpts
	  (without-gcing
	   (breakpoint-remove (get-lisp-obj-address
			       (breakpoint-data-component data))
			      (breakpoint-data-offset data)
			      (breakpoint-data-instruction data)))
	  (delete-breakpoint-data data))))
  (setf (breakpoint-status breakpoint) :inactive)
  breakpoint)

;;;; BREAKPOINT-INFO

(defun breakpoint-info (breakpoint)
  #!+sb-doc
  "This returns the user-maintained info associated with breakpoint. This
   is SETF'able."
  (breakpoint-%info breakpoint))
(defun %set-breakpoint-info (breakpoint value)
  (setf (breakpoint-%info breakpoint) value)
  (let ((other (breakpoint-unknown-return-partner breakpoint)))
    (when other
      (setf (breakpoint-%info other) value))))

;;;; BREAKPOINT-ACTIVE-P and DELETE-BREAKPOINT

(defun breakpoint-active-p (breakpoint)
  #!+sb-doc
  "This returns whether breakpoint is currently active."
  (ecase (breakpoint-status breakpoint)
    (:active t)
    ((:inactive :deleted) nil)))

(defun delete-breakpoint (breakpoint)
  #!+sb-doc
  "This frees system storage and removes computational overhead associated with
   breakpoint. After calling this, breakpoint is completely impotent and can
   never become active again."
  (let ((status (breakpoint-status breakpoint)))
    (unless (eq status :deleted)
      (when (eq status :active)
	(deactivate-breakpoint breakpoint))
      (setf (breakpoint-status breakpoint) :deleted)
      (let ((other (breakpoint-unknown-return-partner breakpoint)))
	(when other
	  (setf (breakpoint-status other) :deleted)))
      (when (eq (breakpoint-kind breakpoint) :function-end)
	(let* ((starter (breakpoint-start-helper breakpoint))
	       (breakpoints (delete breakpoint
				    (the list (breakpoint-info starter)))))
	  (setf (breakpoint-info starter) breakpoints)
	  (unless breakpoints
	    (delete-breakpoint starter)
	    (setf (compiled-debug-function-end-starter
		   (breakpoint-what breakpoint))
		  nil))))))
  breakpoint)

;;;; C call out stubs

;;; This actually installs the break instruction in the component. It
;;; returns the overwritten bits. You must call this in a context in
;;; which GC is disabled, so that Lisp doesn't move objects around
;;; that C is pointing to.
(sb!alien:def-alien-routine "breakpoint_install" sb!c-call:unsigned-long
  (code-obj sb!c-call:unsigned-long)
  (pc-offset sb!c-call:int))

;;; This removes the break instruction and replaces the original
;;; instruction. You must call this in a context in which GC is disabled
;;; so Lisp doesn't move objects around that C is pointing to.
(sb!alien:def-alien-routine "breakpoint_remove" sb!c-call:void
  (code-obj sb!c-call:unsigned-long)
  (pc-offset sb!c-call:int)
  (old-inst sb!c-call:unsigned-long))

(sb!alien:def-alien-routine "breakpoint_do_displaced_inst" sb!c-call:void
  (scp (* os-context-t))
  (orig-inst sb!c-call:unsigned-long))

;;;; breakpoint handlers (layer between C and exported interface)

;;; This maps components to a mapping of offsets to breakpoint-datas.
(defvar *component-breakpoint-offsets* (make-hash-table :test 'eq))

;;; This returns the breakpoint-data associated with component cross
;;; offset. If none exists, this makes one, installs it, and returns it.
(defun breakpoint-data (component offset &optional (create t))
  (flet ((install-breakpoint-data ()
	   (when create
	     (let ((data (make-breakpoint-data component offset)))
	       (push (cons offset data)
		     (gethash component *component-breakpoint-offsets*))
	       data))))
    (let ((offsets (gethash component *component-breakpoint-offsets*)))
      (if offsets
	  (let ((data (assoc offset offsets)))
	    (if data
		(cdr data)
		(install-breakpoint-data)))
	  (install-breakpoint-data)))))

;;; We use this when there are no longer any active breakpoints
;;; corresponding to data.
(defun delete-breakpoint-data (data)
  (let* ((component (breakpoint-data-component data))
	 (offsets (delete (breakpoint-data-offset data)
			  (gethash component *component-breakpoint-offsets*)
			  :key #'car)))
    (if offsets
	(setf (gethash component *component-breakpoint-offsets*) offsets)
	(remhash component *component-breakpoint-offsets*)))
  (values))

;;; The C handler for interrupts calls this when it has a
;;; debugging-tool break instruction. This does NOT handle all breaks;
;;; for example, it does not handle breaks for internal errors.
(defun handle-breakpoint (offset component signal-context)
  (/show0 "entering HANDLE-BREAKPOINT")
  (let ((data (breakpoint-data component offset nil)))
    (unless data
      (error "unknown breakpoint in ~S at offset ~S"
	      (debug-function-name (debug-function-from-pc component offset))
	      offset))
    (let ((breakpoints (breakpoint-data-breakpoints data)))
      (if (or (null breakpoints)
	      (eq (breakpoint-kind (car breakpoints)) :function-end))
	  (handle-function-end-breakpoint-aux breakpoints data signal-context)
	  (handle-breakpoint-aux breakpoints data
				 offset component signal-context)))))

;;; This holds breakpoint-datas while invoking the breakpoint hooks
;;; associated with that particular component and location. While they
;;; are executing, if we hit the location again, we ignore the
;;; breakpoint to avoid infinite recursion. Function-end breakpoints
;;; must work differently since the breakpoint-data is unique for each
;;; invocation.
(defvar *executing-breakpoint-hooks* nil)

;;; This handles code-location and debug-function :FUNCTION-START
;;; breakpoints.
(defun handle-breakpoint-aux (breakpoints data offset component signal-context)
  (/show0 "entering HANDLE-BREAKPOINT-AUX")
  (unless breakpoints
    (error "internal error: breakpoint that nobody wants"))
  (unless (member data *executing-breakpoint-hooks*)
    (let ((*executing-breakpoint-hooks* (cons data
					      *executing-breakpoint-hooks*)))
      (invoke-breakpoint-hooks breakpoints component offset)))
  ;; At this point breakpoints may not hold the same list as
  ;; BREAKPOINT-DATA-BREAKPOINTS since invoking hooks may have allowed
  ;; a breakpoint deactivation. In fact, if all breakpoints were
  ;; deactivated then data is invalid since it was deleted and so the
  ;; correct one must be looked up if it is to be used. If there are
  ;; no more breakpoints active at this location, then the normal
  ;; instruction has been put back, and we do not need to
  ;; DO-DISPLACED-INST.
  (let ((data (breakpoint-data component offset nil)))
    (when (and data (breakpoint-data-breakpoints data))
      ;; The breakpoint is still active, so we need to execute the
      ;; displaced instruction and leave the breakpoint instruction
      ;; behind. The best way to do this is different on each machine,
      ;; so we just leave it up to the C code.
      (breakpoint-do-displaced-inst signal-context
				    (breakpoint-data-instruction data))
      ; Under HPUX we can't sigreturn so bp-do-disp-i has to return.
      #!-(or hpux irix x86)
      (error "BREAKPOINT-DO-DISPLACED-INST returned?"))))

(defun invoke-breakpoint-hooks (breakpoints component offset)
  (let* ((debug-fun (debug-function-from-pc component offset))
	 (frame (do ((f (top-frame) (frame-down f)))
		    ((eq debug-fun (frame-debug-function f)) f))))
    (dolist (bpt breakpoints)
      (funcall (breakpoint-hook-function bpt)
	       frame
	       ;; If this is an :UNKNOWN-RETURN-PARTNER, then pass the
	       ;; hook function the original breakpoint, so that users
	       ;; aren't forced to confront the fact that some
	       ;; breakpoints really are two.
	       (if (eq (breakpoint-kind bpt) :unknown-return-partner)
		   (breakpoint-unknown-return-partner bpt)
		   bpt)))))

(defun handle-function-end-breakpoint (offset component context)
  (/show0 "entering HANDLE-FUNCTION-END-BREAKPOINT")
  (let ((data (breakpoint-data component offset nil)))
    (unless data
      (error "unknown breakpoint in ~S at offset ~S"
	      (debug-function-name (debug-function-from-pc component offset))
	      offset))
    (let ((breakpoints (breakpoint-data-breakpoints data)))
      (when breakpoints
	(aver (eq (breakpoint-kind (car breakpoints)) :function-end))
	(handle-function-end-breakpoint-aux breakpoints data context)))))

;;; Either HANDLE-BREAKPOINT calls this for :FUNCTION-END breakpoints
;;; [old C code] or HANDLE-FUNCTION-END-BREAKPOINT calls this directly
;;; [new C code].
(defun handle-function-end-breakpoint-aux (breakpoints data signal-context)
  (/show0 "entering HANDLE-FUNCTION-END-BREAKPOINT-AUX")
  (delete-breakpoint-data data)
  (let* ((scp
	  (locally
	    (declare (optimize (inhibit-warnings 3)))
	    (sb!alien:sap-alien signal-context (* os-context-t))))
	 (frame (do ((cfp (sb!vm:context-register scp sb!vm::cfp-offset))
		     (f (top-frame) (frame-down f)))
		    ((= cfp (sap-int (frame-pointer f))) f)
		  (declare (type (unsigned-byte #.sb!vm:word-bits) cfp))))
	 (component (breakpoint-data-component data))
	 (cookie (gethash component *function-end-cookies*)))
    (remhash component *function-end-cookies*)
    (dolist (bpt breakpoints)
      (funcall (breakpoint-hook-function bpt)
	       frame bpt
	       (get-function-end-breakpoint-values scp)
	       cookie))))

(defun get-function-end-breakpoint-values (scp)
  (let ((ocfp (int-sap (sb!vm:context-register
			scp
			#!-x86 sb!vm::ocfp-offset
			#!+x86 sb!vm::ebx-offset)))
	(nargs (make-lisp-obj
		(sb!vm:context-register scp sb!vm::nargs-offset)))
 	(reg-arg-offsets '#.sb!vm::*register-arg-offsets*)
	(results nil))
    (without-gcing
     (dotimes (arg-num nargs)
       (push (if reg-arg-offsets
		 (make-lisp-obj
		  (sb!vm:context-register scp (pop reg-arg-offsets)))
	       (stack-ref ocfp arg-num))
	     results)))
    (nreverse results)))

;;;; MAKE-BOGUS-LRA (used for :FUNCTION-END breakpoints)

(defconstant
  bogus-lra-constants
  #!-x86 2 #!+x86 3)
(defconstant
  known-return-p-slot
  (+ sb!vm:code-constants-offset #!-x86 1 #!+x86 2))

;;; FIXME: This is also defined in debug-vm.lisp. Which definition
;;; takes precedence? (One definition uses ALLOCATE-CODE-OBJECT, and
;;; the other has been hacked for X86 GENCGC to use
;;; ALLOCATE-DYNAMIC-CODE-OBJECT..)
(defun make-bogus-lra (real-lra &optional known-return-p)
  #!+sb-doc
  "Make a bogus LRA object that signals a breakpoint trap when returned to. If
   the breakpoint trap handler returns, REAL-LRA is returned to. Three values
   are returned: the bogus LRA object, the code component it is part of, and
   the PC offset for the trap instruction."
  (without-gcing
   (let* ((src-start (foreign-symbol-address "function_end_breakpoint_guts"))
	  (src-end (foreign-symbol-address "function_end_breakpoint_end"))
	  (trap-loc (foreign-symbol-address "function_end_breakpoint_trap"))
	  (length (sap- src-end src-start))
	  (code-object
	   (%primitive
	    #!-(and x86 gencgc) sb!c:allocate-code-object
	    #!+(and x86 gencgc) sb!c::allocate-dynamic-code-object
	    (1+ bogus-lra-constants)
	    length))
	  (dst-start (code-instructions code-object)))
     (declare (type system-area-pointer
		    src-start src-end dst-start trap-loc)
	      (type index length))
     (setf (%code-debug-info code-object) :bogus-lra)
     (setf (code-header-ref code-object sb!vm:code-trace-table-offset-slot)
	   length)
     #!-x86
     (setf (code-header-ref code-object real-lra-slot) real-lra)
     #!+x86
     (multiple-value-bind (offset code) (compute-lra-data-from-pc real-lra)
       (setf (code-header-ref code-object real-lra-slot) code)
       (setf (code-header-ref code-object (1+ real-lra-slot)) offset))
     (setf (code-header-ref code-object known-return-p-slot)
	   known-return-p)
     (system-area-copy src-start 0 dst-start 0 (* length sb!vm:byte-bits))
     (sb!vm:sanctify-for-execution code-object)
     #!+x86
     (values dst-start code-object (sap- trap-loc src-start))
     #!-x86
     (let ((new-lra (make-lisp-obj (+ (sap-int dst-start)
				      sb!vm:other-pointer-type))))
       (set-header-data
	new-lra
	(logandc2 (+ sb!vm:code-constants-offset bogus-lra-constants 1)
		  1))
       (sb!vm:sanctify-for-execution code-object)
       (values new-lra code-object (sap- trap-loc src-start))))))

;;;; miscellaneous

;;; This appears here because it cannot go with the debug-function
;;; interface since DO-DEBUG-BLOCK-LOCATIONS isn't defined until after
;;; the debug-function routines.

(defun debug-function-start-location (debug-fun)
  #!+sb-doc
  "This returns a code-location before the body of a function and after all
   the arguments are in place. If this cannot determine that location due to
   a lack of debug information, it returns nil."
  (etypecase debug-fun
    (compiled-debug-function
     (code-location-from-pc debug-fun
			    (sb!c::compiled-debug-function-start-pc
			     (compiled-debug-function-compiler-debug-fun
			      debug-fun))
			    nil))
    (interpreted-debug-function
     ;; Return the first location if there are any, otherwise NIL.
     (handler-case (do-debug-function-blocks (block debug-fun nil)
		     (do-debug-block-locations (loc block nil)
		       (return-from debug-function-start-location loc)))
       (no-debug-blocks (condx)
	 (declare (ignore condx))
	 nil)))))

(defun print-code-locations (function)
  (let ((debug-fun (function-debug-function function)))
    (do-debug-function-blocks (block debug-fun)
      (do-debug-block-locations (loc block)
	(fill-in-code-location loc)
	(format t "~S code location at ~D"
		(compiled-code-location-kind loc)
		(compiled-code-location-pc loc))
	(sb!debug::print-code-location-source-form loc 0)
	(terpri)))))
