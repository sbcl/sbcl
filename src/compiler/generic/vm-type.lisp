;;;; This file contains implementation-dependent parts of the type
;;;; support code. This is stuff which deals with the mapping from
;;;; types defined in Common Lisp to types actually supported by an
;;;; implementation.

;;;; This software is part of the SBCL system. See the README file for
;;;; more information.
;;;;
;;;; This software is derived from the CMU CL system, which was
;;;; written at Carnegie Mellon University and released into the
;;;; public domain. The software is in the public domain and is
;;;; provided with absolutely no warranty. See the COPYING and CREDITS
;;;; files for more information.

(in-package "SB!KERNEL")

(/show0 "vm-type.lisp 17")

(!begin-collecting-cold-init-forms)

;;;; FIXME: I'm not sure where to put this. -- WHN 19990817

(deftype sb!vm:word () `(unsigned-byte ,sb!vm:word-bits))

;;;; implementation-dependent DEFTYPEs

;;; Make DOUBLE-FLOAT a synonym for LONG-FLOAT, SINGLE-FLOAT for SHORT-FLOAT.
;;; This is expanded before the translator gets a chance, so we will get
;;; precedence.
#!-long-float
(setf (info :type :kind 'long-float) :defined)
#!-long-float
(sb!xc:deftype long-float (&optional low high)
  `(double-float ,low ,high))
(setf (info :type :kind 'short-float) :defined)
(sb!xc:deftype short-float (&optional low high)
  `(single-float ,low ,high))

;;; an index into an integer
(sb!xc:deftype bit-index () `(integer 0 ,most-positive-fixnum))

;;; worst-case values for float attributes
(sb!xc:deftype float-exponent ()
  #!-long-float 'double-float-exponent
  #!+long-float 'long-float-exponent)
(sb!xc:deftype float-digits ()
  #!-long-float `(integer 0 ,sb!vm:double-float-digits)
  #!+long-float `(integer 0 ,sb!vm:long-float-digits))
(sb!xc:deftype float-radix () '(integer 2 2))

;;; a code for BOOLE
(sb!xc:deftype boole-code () '(unsigned-byte 4))

;;; a byte specifier (as generated by BYTE)
(sb!xc:deftype byte-specifier () 'cons)

;;; result of CHAR-INT
(sb!xc:deftype char-int () 'char-code)

;;; PATHNAME pieces, as returned by the PATHNAME-xxx functions
(sb!xc:deftype pathname-host () '(or sb!impl::host null))
(sb!xc:deftype pathname-device ()
  '(or simple-string (member nil :unspecific)))
(sb!xc:deftype pathname-directory () 'list)
(sb!xc:deftype pathname-name ()
  '(or simple-string sb!impl::pattern (member nil :unspecific :wild)))
(sb!xc:deftype pathname-type ()
  '(or simple-string sb!impl::pattern (member nil :unspecific :wild)))
(sb!xc:deftype pathname-version ()
  '(or integer (member nil :newest :wild :unspecific)))

;;; internal time format. (Note: not a FIXNUM, ouch..)
(sb!xc:deftype internal-time () 'unsigned-byte)

(sb!xc:deftype bignum-element-type () `(unsigned-byte ,sb!vm:word-bits))
(sb!xc:deftype bignum-type () 'bignum)
(sb!xc:deftype bignum-index () 'index)

;;;; hooks into the type system

;;; the kinds of specialized array that actually exist in this implementation
(defvar *specialized-array-element-types*)
(!cold-init-forms
  (setf *specialized-array-element-types*
	'(bit
	  (unsigned-byte 2)
	  (unsigned-byte 4)
	  (unsigned-byte 8)
	  (unsigned-byte 16)
	  (unsigned-byte 32)
	  (signed-byte 8)
	  (signed-byte 16)
	  (signed-byte 30)
	  (signed-byte 32)
	  (complex single-float)
	  (complex double-float)
	  #!+long-float (complex long-float)
	  base-char
	  single-float
	  double-float
	  #!+long-float long-float)))

(sb!xc:deftype unboxed-array (&optional dims)
  (collect ((types (list 'or)))
    (dolist (type *specialized-array-element-types*)
      (when (subtypep type '(or integer character float (complex float)))
	(types `(array ,type ,dims))))
    (types)))

(sb!xc:deftype simple-unboxed-array (&optional dims)
  (collect ((types (list 'or)))
    (dolist (type *specialized-array-element-types*)
      (when (subtypep type '(or integer character float (complex float)))
	(types `(simple-array ,type ,dims))))
    (types)))

;;; Return the symbol that describes the format of FLOAT.
(declaim (ftype (function (float) symbol) float-format-name))
(defun float-format-name (x)
  (etypecase x
    (single-float 'single-float)
    (double-float 'double-float)
    #!+long-float (long-float 'long-float)))

;;; This function is called when the type code wants to find out how
;;; an array will actually be implemented. We set the
;;; SPECIALIZED-ELEMENT-TYPE to correspond to the actual
;;; specialization used in this implementation.
(declaim (ftype (function (array-type) array-type) specialize-array-type))
(defun specialize-array-type (type)
  (let ((eltype (array-type-element-type type)))
    (setf (array-type-specialized-element-type type)
	  (if (eq eltype *wild-type*)
	      *wild-type*
	      (dolist (stype-name *specialized-array-element-types*
				  *universal-type*)
		;; FIXME: Mightn't it be better to have
		;; *SPECIALIZED-ARRAY-ELEMENT-TYPES* be stored as precalculated
		;; SPECIFIER-TYPE results, instead of having to calculate
		;; them on the fly this way? (Call the new array
		;; *SPECIALIZED-ARRAY-ELEMENT-SPECIFIER-TYPES* or something..)
		(let ((stype (specifier-type stype-name)))
		  (when (csubtypep eltype stype)
		    (return stype))))))
    type))

;;; Return the most specific integer type that can be quickly checked that
;;; includes the given type.
(defun containing-integer-type (subtype)
  (dolist (type '(fixnum
		  (signed-byte 32)
		  (unsigned-byte 32)
		  integer)
		(error "~S isn't an integer type?" subtype))
    (when (csubtypep subtype (specifier-type type))
      (return type))))

;;; If TYPE has a CHECK-xxx template, but doesn't have a corresponding
;;; PRIMITIVE-TYPE, then return the template's name. Otherwise, return NIL.
(defun hairy-type-check-template-name (type)
  (declare (type ctype type))
  (typecase type
    (cons-type
     (if (type= type (specifier-type 'cons))
	 'sb!c:check-cons
	 nil))
    (built-in-class
     (if (type= type (specifier-type 'symbol))
	 'sb!c:check-symbol
	 nil))
    (numeric-type
     (cond ((type= type (specifier-type 'fixnum))
	    'sb!c:check-fixnum)
	   ((type= type (specifier-type '(signed-byte 32)))
	    'sb!c:check-signed-byte-32)
	   ((type= type (specifier-type '(unsigned-byte 32)))
	    'sb!c:check-unsigned-byte-32)
	   (t nil)))
    (fun-type
     'sb!c:check-function)
    (t
     nil)))

(!defun-from-collected-cold-init-forms !vm-type-cold-init)

(/show0 "vm-type.lisp end of file")
